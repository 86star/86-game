<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ğŸ¹ ã¯ã‚€ã“ã‚ã‚Šã‚“</title>
  <style>
    
    body {
  margin: 0;
  padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
  background: linear-gradient(to bottom, #fff5e6, #ffe6cc);
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, 'Apple Color Emoji', 'Segoe UI Emoji';
  display: block;
  min-height: 100svh;
  overflow: hidden;
  box-sizing: border-box;
}
    .game-container {
  background: transparent; /* was #fff, hid the body gradient */
  border-radius: 0;
  padding: 8px;
  box-shadow: none;
  text-align: center;
  width: 100svw;
  height: 100svh;
  overflow: hidden;
  box-sizing: border-box;
}
    .title { color:#e17055; font-size:22px; font-weight:800; margin:6px 0; text-align:center; }
    .score { font-size:20px; font-weight:700; color:#2d3436; margin:6px 0 10px; text-align:center; }
    #gameCanvas {
      border: 1px solid #e17055;
      border-radius: 4px;
      background: #74b9ff;
      display: block;
      margin: 0 auto 4px;
    }
    .controls { margin-bottom: 6px; }
    .btn { background:#00b894; color:#fff; border:none; padding:8px 12px; border-radius:12px; font-size:14px; cursor:pointer; margin:0 2px; transition:transform .15s ease, background .15s ease; user-select:none; }
    .btn:hover { background: #00a085; transform: translateY(-1px); }
    .item-slot {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      padding: 4px;
      background: #fff;
      border: 2px solid #ddd;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      min-width: 40px;
    }
    .item-slot:hover { border-color: #00b894; transform: translateY(-2px); }
    .item-slot.disabled { opacity: 0.5; cursor: not-allowed; }

    .modal { display: none; position: fixed; inset: 0; z-index: 1000; background: rgba(0,0,0,.7); }
    .modal-content {
      background: #fff; margin: 5% auto; padding: 16px; border-radius: 10px; width: 92%; max-width: 560px; max-height: 80vh; overflow: auto;
    }
    .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    .modal-header h2 { color: #e17055; margin: 0; font-size: 18px; }
    .close { color: #999; font-size: 28px; font-weight: 700; cursor: pointer; }
    .close:hover { color: #e17055; }
    .legend-grid { 
      display: flex; 
      flex-direction: column; 
      gap: 15px; 
      align-items: center; 
    }
    .evolution-row { 
      display: flex; 
      align-items: center; 
      gap: 10px; 
      flex-wrap: wrap; 
      justify-content: center; 
    }
    .legend-item { 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      gap: 4px; 
      padding: 8px; 
      background: #f8f9fa; 
      border: 1px solid #e9ecef; 
      border-radius: 8px; 
      min-width: 80px;
    }
    .legend-thumb { 
      width: 32px; 
      height: 32px; 
      border-radius: 50%; 
      object-fit: cover; 
      border: 1px solid #ccc; 
      background: #fff; 
    }
    .legend-name { 
      font-size: 11px; 
      text-align: center; 
      line-height: 1.2;
    }
    .evolution-arrow {
      font-size: 20px;
      color: #e17055;
      font-weight: bold;
    }
    /* ===== Titles toggle (åˆç´š/ä¸­ç´š/ä¸Šç´š) ===== */
.toggle-section {
  margin: 10px 0;
  border: 1px solid #ddd;
  border-radius: 10px;
  overflow: hidden;
  background: #fff;
}
.toggle-header {
  background: #f8f9fa;
  padding: 10px 12px;
  font-weight: bold;
  cursor: pointer;
  text-align: center;
  user-select: none;
}
.toggle-header:hover { background: #f1f3f5; }
.toggle-content {
  display: none; /* åˆæœŸã¯é–‰ã˜ã‚‹ */
  padding: 10px;
}
.toggle-section.open .toggle-content {
  display: block; /* é–‹ã„ãŸã‚‰è¡¨ç¤º */
}

  </style>

<style>
  /* Right-top in-game timer HUD */
  #playtimeHud {
    position: fixed;
    top: 10px;
    right: 12px;
    font: inherit;
    font-size: 1rem;
    line-height: 1;
    z-index: 9999;
    pointer-events: none;
    display: none; /* shown only during gameplay */
  
  color: #000;
}
  @media (min-width: 768px) {
    #playtimeHud { font-size: 1.1rem; }
  }
</style>


    <style>
    /* ===== Titles toggle (åˆç´š/ä¸­ç´š/ä¸Šç´š) ===== */
    .toggle-section {
      margin: 10px 0;
      border: 1px solid #ddd;
      border-radius: 10px;
      overflow: hidden;
      background: #fff;
    }
    .toggle-header {
      background: #f8f9fa;
      padding: 10px 12px;
      font-weight: bold;
      cursor: pointer;
      text-align: center;
      user-select: none;
    }
    .toggle-header:hover { background: #f1f3f5; }
    /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç‰ˆï¼ˆä¸Šæ›¸ãå®šç¾©ï¼‰ */
    .toggle-content {
      display: block;
      max-height: 0;
      overflow: hidden;
      transition: max-height 220ms ease;
      padding: 0 10px;
    }
    .toggle-section.open .toggle-content {
      max-height: 1200px;
    }
    </style>
    

<style>
/* --- Fix: ensure headers are clickable and override old display rules --- */
.toggle-header{position:relative; z-index:1; pointer-events:auto; display:flex; align-items:center; justify-content:center;}
/* If some old CSS set display:none, force our rule to win */
.toggle-content{display:block !important;}
</style>


<style>
/* --- Strong toggle overrides & empty hint --- */
.toggle-section{ border:1px solid #e5e7eb; border-radius:12px; background:#fff; }
.toggle-header{ position:relative; z-index:2; pointer-events:auto; display:flex; align-items:center; justify-content:space-between; gap:8px; padding:12px 16px; font-weight:600; }
.toggle-header::after{ content:''; }
.toggle-content{ display:block !important; max-height:0; overflow:hidden; transition:max-height 240ms ease; padding:0 16px; }
.toggle-section.open .toggle-content{ max-height:1500px !important; }
.empty-hint{ color:#9aa0a6; font-size:13px; padding:8px 0 12px; text-align:center; }
</style>


<script>
// ===== Asset Version (v15) =====
(function(){
  function getQueryVer(){
    try{
      const m = location.search.match(/[?&](?:ver|v|cb)=([^&]+)/i);
      return m ? decodeURIComponent(m[1]) : null;
    }catch(e){ return null; }
  }
  // æ›´æ–°æ™‚ã ã‘ 'v1.0.1' ãªã©ã«å¤‰æ›´ã—ã¦ãã ã•ã„
  window.ASSET_VER = getQueryVer() || 'v1.0.0';
  window.withVer = function(u){
    try{
      if (typeof u !== 'string') return u;
      if (!/\.(png|jpg|jpeg|webp|gif)$/i.test(u)) return u;
      const sep = u.includes('?') ? '&' : '?';
      return u + sep + 'v=' + ASSET_VER;
    }catch(e){ return u; }
  };
})();
</script>
<!-- PWA: manifest & iOS icon -->
<link rel="manifest" href="manifest.webmanifest">
<link rel="apple-touch-icon" href="assets/icon-180.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">

</head>
<body>
<div id="playtimeHud" aria-hidden="true"></div>


<script id="shim-showhelp-once">
(function(){
  if (typeof window.showHelp !== 'function') {
    window.showHelp = function(){ var m=document.getElementById('helpModal'); if(m) m.style.display='block'; };
  }
  if (typeof window.showRecipe !== 'function') {
    window.showRecipe = function(){ var m=document.getElementById('recipeModal'); if(m) m.style.display='block'; };
  }
})();




// ã‚¿ã‚¤ãƒãƒ¼å‡¦ç†
let playTimeInterval;
function startPlayTimer(){
  var hud=document.getElementById('playtimeHud');
  if(hud){hud.style.display='block'; hud.textContent='ãƒ—ãƒ¬ã‚¤æ™‚é–“: 0:00';}

  if (playTimeInterval) clearInterval(playTimeInterval);
  playTimeInterval = setInterval(() => {
    const elapsed = getActualPlayTime ? getActualPlayTime() : 0;
    const mins = Math.floor(elapsed / 60);
    const secs = elapsed % 60;
    var hud=document.getElementById('playtimeHud'); if(hud){hud.textContent=`ãƒ—ãƒ¬ã‚¤æ™‚é–“: ${mins}:${secs.toString().padStart(2,"0")}`;}
  }, 1000);
}

function stopPlayTimer(){
  var hud=document.getElementById('playtimeHud');
  if(hud){hud.style.display='none';}

  if (playTimeInterval) {
    clearInterval(playTimeInterval);
    playTimeInterval = null;
  }
}

</script>

  <div class="game-container">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;gap:8px;">
      <h1 class="title">ğŸ¹ ã¯ã‚€ã“ã‚ã‚Šã‚“</h1>
    </div>
    <div id="menuButtons" style="display:flex; justify-content:center; gap:8px; flex-wrap:wrap; margin-bottom:4px;">

      <button class="btn" onclick="showHelp()" title="ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ«">â“ ãƒ«ãƒ¼ãƒ«</button>
      <button class="btn" onclick="showLegend()" title="åˆä½“ãƒ¬ã‚·ãƒ”">ğŸ“– ãƒ¬ã‚·ãƒ”</button>
      <button class="btn" onclick="showHighScores()" title="ãƒã‚¤ã‚¹ã‚³ã‚¢å±¥æ­´">ğŸ† è¨˜éŒ²</button>
      <button class="btn" onclick="showTitles()" title="ç§°å·ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³">ğŸ‘‘ ç§°å·</button>
    </div>
    <div style="display: none; justify-content: center; gap: 8px; margin-bottom: 4px;" id="gameButtons">
      <button class="btn" onclick="togglePause()" id="pauseBtn" title="ä¸€æ™‚åœæ­¢/å†é–‹">â¸ï¸ åœæ­¢</button>
      <button class="btn" onclick="resetGame()" style="background:#e74c3c;" id="resetBtn" title="ã‚²ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
      <button class="btn" onclick="showTitles()" title="ç§°å·ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³">ğŸ‘‘ ç§°å·</button>
    </div>
    <div class="score" id="gameScore">ã‚¹ã‚³ã‚¢: <span id="score">0</span> | ãƒã‚¤ã‚¹ã‚³ã‚¢: <span id="highscore">0</span><span id="time-separator" style="display:none;"> | æ™‚é–“: </span><span id="playtime" style="display:none;">0:00</span></div>
    
    <div style="display: flex; flex-direction: column; align-items: center; gap: 8px; margin-bottom: 4px;" id="gameUI">
      <div style="display: none; align-items: center; justify-content: center; gap: 8px;" id="gameControls">
        <div style="font-size: 12px; font-weight: bold; color: #e17055;">NEXT:</div>
        <div id="nextPreview" style="width: 50px; height: 50px; border: 2px solid #e17055; border-radius: 6px; background: #74b9ff; display: flex; align-items: center; justify-content: center;">
        </div>
<div class="item-slot" onclick="useEraser()" id="item-eraser">
  <img src="assets/eraser.png" 
       alt="eraser" 
       style="width:24px; height:24px; border-radius:4px; object-fit:contain;" />
  <div style="font-size: 9px; font-weight: bold; color: #2d3436;">Ã—<span id="eraser-count">2</span></div>
</div>

      </div>
      <canvas id="gameCanvas" width="350" height="380"></canvas>
<div id="promoLinks" style="text-align:center; margin:12px 0 0;">
  <button id="installBtn" class="btn" style="background:#e17055; padding:12px 16px; border-radius:14px; font-size:16px; display:inline-block;">ğŸ“± ã‚¢ãƒ—ãƒªã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
  <div style="margin-top:10px;">
    <a id="ytLink" href="https://youtube.com/@hamuchira?si=8Xq6HUJSTb59RWvB" target="_blank" rel="noopener"
       style="display:inline-block; text-decoration:none; background:#ffb347; color:#fff; padding:12px 16px; border-radius:14px; font-size:16px;">
      â–¶ï¸ ã‚‚ã£ã¨ï¼ã¯ã‚€ãƒãƒ©é•·å±‹ch.
    </a>
    <!-- â–¼ã‚·ã‚§ã‚¢ï¼†ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆytLinkã®ç›´å¾Œã«è¿½åŠ ï¼‰ -->
<div id="shareArea" style="margin-top:12px; text-align:center;">
  <a id="shareX" href="#" target="_blank"
     style="margin:0 6px; text-decoration:none; font-size:14px; padding:6px 10px; border-radius:6px; background:#000; color:#fff;">
    Xã§ã‚·ã‚§ã‚¢
  </a>

  <a id="shareLine" href="#" target="_blank"
     style="margin:0 6px; text-decoration:none; font-size:14px; padding:6px 10px; border-radius:6px; background:#06c755; color:#fff;">
    LINEã§ã‚·ã‚§ã‚¢
  </a>

  <button id="copyUrlBtn"
     style="margin:0 6px; font-size:14px; padding:6px 10px; border-radius:6px; background:#888; color:#fff; border:none; cursor:pointer;">
    URLã‚³ãƒ”ãƒ¼
  </button>

  <div style="margin-top:12px;">
    <img src="assets/icon-192.png" alt="ã‚¢ãƒ—ãƒªã‚¢ã‚¤ã‚³ãƒ³" width="64" height="64" style="border-radius:12px;">
  </div>
</div>
<!-- â–²ã“ã“ã¾ã§ -->

    <script>
document.addEventListener('DOMContentLoaded', () => {
  const url   = location.href;
  const title = document.title;

  // Xã‚·ã‚§ã‚¢
  const xBtn = document.getElementById('shareX');
  if (xBtn) {
    xBtn.href = `https://x.com/intent/tweet?url=${encodeURIComponent(url)}&text=${encodeURIComponent(title)}`;
  }

  // LINEã‚·ã‚§ã‚¢
  const lineBtn = document.getElementById('shareLine');
  if (lineBtn) {
    lineBtn.href = `https://line.me/R/msg/text/?${encodeURIComponent(title + " " + url)}`;
  }

  // URLã‚³ãƒ”ãƒ¼
  const copyBtn = document.getElementById('copyUrlBtn');
  if (copyBtn) {
    copyBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(url);
        copyBtn.textContent = "ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼";
        setTimeout(() => copyBtn.textContent = "URLã‚³ãƒ”ãƒ¼", 2000);
      } catch (e) {
        alert("ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ: " + e);
      }
    });
  }
});
</script>

  </div>
</div>
    </div>
    <div class="controls" id="moveControls" style="display: none;">
      <button class="btn" id="btnLeft" onclick="moveLeft()">â† å·¦</button>
      <button class="btn" id="btnDrop" onclick="drop()">â¬‡ ãƒ‰ãƒ­ãƒƒãƒ—</button>
      <button class="btn" id="btnRight" onclick="moveRight()">â†’ å³</button>
    </div>
  </div>

  <div id="legendModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>ğŸ“– ã¯ã‚€ã“ã‚ã‚Šã‚“åˆä½“ãƒ¬ã‚·ãƒ”</h2>
        <span class="close" onclick="hideLegend()">&times;</span>
      </div>
      <div id="legendGrid" class="legend-grid"></div>
    </div>
  </div>

  <div id="helpModal" class="modal">
    <div class="modal-content">
  <div class="modal-header">
    <h2>â“ ã¯ã‚€ã“ã‚ã‚Šã‚“ãƒ«ãƒ¼ãƒ«ãƒ»éŠã³æ–¹</h2>
    <span class="close" onclick="hideHelp()">&times;</span>
  </div>
  <div style="text-align: left; line-height: 1.7;">
    <h3 style="color:#e17055;margin-top:0;">ğŸ® ã‚²ãƒ¼ãƒ ã®ãƒ«ãƒ¼ãƒ«</h3>
    <h4>1. ã‚ãã³ã‹ãŸ</h4>
    <ul>
      <li>ç”»é¢ã‚’ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨ã€ãƒãƒ ã‚¹ã‚¿ãƒ¼ãŒè½ã¡ã¦ãã¾ã™ã€‚</li>
      <li>åŒã˜ãƒãƒ ã‚¹ã‚¿ãƒ¼åŒå£«ãŒãã£ã¤ãã¨ã€é€²åŒ–ã—ã¦å¤§ãããªã‚Šã¾ã™ã€‚</li>
      <li>é€²åŒ–ã™ã‚‹ãŸã³ã«ã‚¹ã‚³ã‚¢ãŒå…¥ã‚Šã¾ã™ã€‚</li>
    </ul>

    <h4>2. ã‘ã—ã”ã‚€</h4>
    <ul>
      <li>é‚ªé­”ãªãƒãƒ ã‚¹ã‚¿ãƒ¼ã‚’ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨ã€<strong>ã‘ã—ã”ã‚€</strong>ã§æ¶ˆã›ã¾ã™ã€‚</li>
      <li><strong>1ãƒ—ãƒ¬ã‚¤ã«ã¤ã2å›ã¾ã§</strong> ä½¿ç”¨ã§ãã¾ã™ã€‚</li>
    </ul>

    <h4>3. ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h4>
    <ul>
      <li>ãƒãƒ ã‚¹ã‚¿ãƒ¼ãŒä¸Šã¾ã§ç©ã¿ã‚ãŒã‚‹ã¨ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã§ã™ã€‚</li>
    </ul>

    <h4>4. ç§°å·ã‚·ã‚¹ãƒ†ãƒ </h4>
    <ul>
      <li><strong>åˆç´š</strong>ï¼šåŸºæœ¬ã®æŒ‘æˆ¦ã€‚æ¡ä»¶ã‚’æº€ãŸã™ã¨è§£æ”¾ã€‚</li>
      <li><strong>ä¸­ç´š</strong>ï¼šåˆç´šã‚’ã™ã¹ã¦å–ã‚‹ã¨æŒ‘æˆ¦ã§ãã¾ã™ã€‚</li>
      <li><strong>ä¸Šç´š</strong>ï¼šä¸­ç´šã‚’ã™ã¹ã¦å–ã‚‹ã¨æŒ‘æˆ¦ã§ãã¾ã™ã€‚</li>
    </ul>

    <h4>5. ã‚¹ã‚³ã‚¢ã®ã‚³ãƒ„</h4>
    <ul>
      <li>é€²åŒ–ã•ã›ã¦ <strong>å¤§ããªãƒãƒ ã‚¹ã‚¿ãƒ¼</strong> ã‚’ä½œã‚‹ã»ã©é«˜å¾—ç‚¹ï¼</li>
      <li>ã‘ã—ã”ã‚€ã‚’ã†ã¾ãä½¿ã†ã¨ã€é€²åŒ–ã‚’ç‹™ã„ã‚„ã™ããªã‚Šã¾ã™ã€‚</li>
    </ul>
  </div>
</div>
  </div>

  <div id="titleModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>ğŸ‘‘ ã¯ã‚€ã“ã‚ã‚Šã‚“ç§°å·ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³</h2>
        <span class="close" onclick="hideTitles()">&times;</span>
      </div>
      <div id="titleList" style="margin: 20px 0;"></div>
      <div style="text-align: center; margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee;">
        <button class="btn" onclick="hideTitles()" style="background: #e17055; padding: 8px 16px;">ğŸ“± ã‚²ãƒ¼ãƒ ã«æˆ»ã‚‹</button>
      </div>
    </div>
  </div>

  <div id="highScoreModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>ğŸ† ãƒã‚¤ã‚¹ã‚³ã‚¢å±¥æ­´</h2>
        <span class="close" onclick="hideHighScores()">&times;</span>
      </div>
      <div style="text-align: center;">
        <div id="highScoreList" style="margin: 20px 0;"></div>
        <div style="text-align: center; margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee;">
          <button class="btn" onclick="hideHighScores()" style="background: #e17055; padding: 8px 16px;">ğŸ“± ã‚²ãƒ¼ãƒ ã«æˆ»ã‚‹</button>
        </div>
      </div>
    </div>
  </div>

  <script>
window.shareButtons = null;
window.lastScore = 0;

function screenXYToCanvas(e) {
  const rect = canvas.getBoundingClientRect();
  const cx = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
  const cy = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
  return {x: cx, y: cy};
}

    // === Responsive Layout Helpers ===
    function getViewportSize() {
      const vw = Math.min(window.innerWidth, (window.visualViewport ? window.visualViewport.width : window.innerWidth));
      const vh = (window.visualViewport ? window.visualViewport.height : window.innerHeight);
      return { vw, vh };
    }
    function outerVerticalSpacing(el) {
      if (!el) return 0;
      const cs = getComputedStyle(el);
      return el.offsetHeight + parseFloat(cs.marginTop || 0) + parseFloat(cs.marginBottom || 0);
    }
    function resizeGame() {
      const container = document.querySelector('.game-container');
      const titleEl = document.querySelector('.title');
      const menuButtons = document.getElementById('menuButtons');
      const gameButtons = document.getElementById('gameButtons');
      const scoreBar = document.getElementById('gameScore');
      const gameUI = document.getElementById('gameUI');
      const controls = document.getElementById('moveControls');
      const { vw, vh } = getViewportSize();
      
      // Container fills viewport
      container.style.width = vw + 'px';
      container.style.height = vh + 'px';
      
      // Compute paddings
      const cs = getComputedStyle(container);
      const padTop = parseFloat(cs.paddingTop) || 0;
      const padBottom = parseFloat(cs.paddingBottom) || 0;
      
      // Fixed blocks height (above and below canvas)
      const topBlocks = outerVerticalSpacing(titleEl) 
                      + outerVerticalSpacing(menuButtons.style.display !== 'none' ? menuButtons : gameButtons) 
                      + outerVerticalSpacing(scoreBar) 
                      + outerVerticalSpacing(document.getElementById('gameControls')); // NEXTã¨æ¶ˆã—ã‚´ãƒ æ¬„ï¼ˆdisplayã§å¤‰å‹•ï¼‰
      const bottomBlocks = outerVerticalSpacing(controls) + outerVerticalSpacing(document.getElementById('promoLinks'));
      
      const availableH = Math.max(120, vh - padTop - padBottom - topBlocks - bottomBlocks - 8);
      const availableW = Math.max(200, vw - (parseFloat(cs.paddingLeft)||0) - (parseFloat(cs.paddingRight)||0) - 8);
      
      // Keep a gentle aspect ratio by clamping height vs width
      // Prefer full width, then height fills remaining
      const targetW = availableW;
      const targetH = availableH;
      
      const canvas = document.getElementById('gameCanvas');
      // Apply pixel size (affects physics) and CSS size
      canvas.width = Math.floor(targetW);
      canvas.height = Math.floor(targetH);
      canvas.style.width = targetW + 'px';
      canvas.style.height = targetH + 'px';
    }
    window.addEventListener('resize', resizeGame);
    window.addEventListener('orientationchange', () => setTimeout(resizeGame, 150));
    // When virtual keyboard changes the visual viewport
    if (window.visualViewport) {
      visualViewport.addEventListener('resize', resizeGame);
    }
    // Rerun when UI rows toggle visibility
    const _origShow = {
      menu: null
    };
    // Hook showing/hiding menus by wrapping functions later after they are defined.
    
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    // Replaced by renderScore helper
const scoreElement = null;
function renderScore(){
  const nodes = document.querySelectorAll('#gameScore span#score');
  nodes.forEach(n=>{ n.textContent = gameState.score; });
}

    const eraserElement = document.getElementById('eraser-count');
    const nextPreview = document.getElementById('nextPreview');

    let nextCanvas, nextCtx;
    let unlockedHamsters = new Set();
    let eraserMode = false;
    let eraserCount = 2;
    
    const gravity = 0.5;
    const friction = 0.95;
    const wallBounce = 0.6;
    const groundBounce = 0.3;

    const foodTypes = [
      { size: 15, points: 1,   name: 'ãƒ‰ãƒ¯ãƒ¼ãƒ•ãƒãƒ ã‚¹ã‚¿ãƒ¼' },
      { size: 20, points: 2,   name: 'ãƒ­ãƒœãƒ­ãƒ•ã‚¹ã‚­ãƒ¼' },
      { size: 25, points: 4,   name: 'ã‚­ãƒ³ã‚¯ãƒ' },
      { size: 30, points: 8,   name: 'ã‚¸ãƒ£ãƒ³ã‚¬ãƒªã‚¢ãƒ³' },
      { size: 35, points: 16,  name: 'ã‚­ãƒ£ãƒ³ãƒ™ãƒ«' },
      { size: 40, points: 32,  name: 'ãƒãƒ£ã‚¤ãƒ‹ãƒ¼ã‚º' },
      { size: 45, points: 64,  name: 'ã‚·ãƒªã‚¢ãƒ³(ã‚¯ãƒªãƒ¼ãƒ )' },
      { size: 50, points: 128, name: 'ã‚·ãƒªã‚¢ãƒ³(ç™½)' },
      { size: 55, points: 256, name: 'ã‚´ãƒ¼ãƒ«ãƒ‡ãƒ³' },
      { size: 60, points: 512, name: 'ãƒ¬ã‚¢ãƒãƒ ã‚¹ã‚¿ãƒ¼' },
      { size: 65, points: 1024,name: 'ä¼èª¬ã®ãƒãƒ ã‚¹ã‚¿ãƒ¼' },
    ];

    const hamsterColors = [
      '#FFB6C1', '#87CEEB', '#98FB98', '#DDA0DD', '#F0E68C', '#FFA07A', 
      '#20B2AA', '#FF69B4', '#FFD700', '#FF1493', '#8A2BE2'
    ];

    let gameState = {
      balls: [],
      currentBall: null,
      nextBall: null,
      score: 0,
      dropX: canvas.width / 2,
      gameOver: false,
      gameStarted: false,
      paused: false,
      particles: [],
      legendaryCount: 0,
      scoreSaved: false,
      dropTimer: 0,           // ãƒ‰ãƒ­ãƒƒãƒ—ã‹ã‚‰ã®çµŒéæ™‚é–“
      comboCount: 0,          // ç¾åœ¨ã®ã‚³ãƒ³ãƒœæ•°
      maxCombo: 0,            // æœ€å¤§ã‚³ãƒ³ãƒœæ•°
      lastMergeTime: 0        // æœ€å¾Œã®åˆä½“æ™‚é–“
    };

    let gameStartTime = 0;
    let highScores = [];
    
    // ç§°å·ã‚·ã‚¹ãƒ†ãƒ ï¼ˆæ®µéšåˆ¶ï¼‰
    let titles = [

      
      // åˆç´šç§°å·ï¼ˆ1-10ç•ªï¼‰
      { id: 1,  name: "åˆä½“100é”æˆ",     icon: "âœ¨", description: "100å›åˆä½“ã«æˆåŠŸã—ãŸ",                       condition: "merge_100",         unlocked: false, tier: "åˆç´š" },
      { id: 2,  name: "ãƒãƒ¼æ¶ˆã—10000",   icon: "ğŸš«ğŸ§¹", description: "ã‘ã—ã”ã‚€ã‚’ä½¿ã‚ãšã«10000ç‚¹ç²å¾—",          condition: "no_eraser_10000",   unlocked: false, tier: "åˆç´š" },
      { id: 3,  name: "ã‚¹ã‚³ã‚¢20000",     icon: "ğŸ¯", description: "ã‚¹ã‚³ã‚¢20000ç‚¹ã‚’é”æˆã—ãŸ",                  condition: "score_20000",       unlocked: false, tier: "åˆç´š" },
      { id: 4,  name: "ã‚­ãƒ³ã‚¯ãƒ50ç´¯è¨ˆ", icon: "ğŸ§¡", description: "ã‚­ãƒ³ã‚¯ãƒãƒãƒ ã‚¹ã‚¿ãƒ¼ã‚’ç´¯è¨ˆ50åŒ¹ä½œã£ãŸ",        condition: "kinkuma_50",        unlocked: false, tier: "åˆç´š" },
      { id: 5,  name: "5åˆ†çµŒé",         icon: "â°", description: "ã‚²ãƒ¼ãƒ é–‹å§‹ã‹ã‚‰5åˆ†çµŒéã—ãŸ",                condition: "time_5min",         unlocked: false, tier: "åˆç´š" },
      { id: 6,  name: "3å›ãƒ—ãƒ¬ã‚¤",       icon: "ğŸ”„", description: "3å›ã‚²ãƒ¼ãƒ ã‚’ãƒ—ãƒ¬ã‚¤ã—ãŸ",                    condition: "game_3plays",       unlocked: false, tier: "åˆç´š" },
      { id: 7,  name: "ç´¯è¨ˆ10åˆ†",       icon: "â³", description: "ç´¯è¨ˆæ™‚é–“10åˆ†çµŒéã—ãŸ",                      condition: "total_time_10min",  unlocked: false, tier: "åˆç´š" },
      { id: 8,  name: "1åˆ†ã§5000",       icon: "âš¡", description: "1åˆ†ä»¥å†…ã«5000ç‚¹ç²å¾—",                      condition: "speed_5000_1min",   unlocked: false, tier: "åˆç´š" },
      { id: 9,  name: "ã‚¿ãƒƒãƒ—200",       icon: "ğŸ‘†", description: "ç”»é¢ã‚’ç´¯è¨ˆ200å›ã‚¿ãƒƒãƒ—ã—ãŸ",                 condition: "tap_200",           unlocked: false, tier: "åˆç´š" },
      { id: 10, name: "ä¼èª¬Ã—2ï¼ˆ1å›ï¼‰",  icon: "ğŸ‘‘", description: "1å›ã®ã‚²ãƒ¼ãƒ ã§ä¼èª¬ãƒãƒ ã‚¹ã‚¿ãƒ¼ã‚’2åŒ¹ä½œã£ãŸ",    condition: "legendary_2_once",  unlocked: false, tier: "åˆç´š" },
      
      // ä¸­ç´šç§°å·ï¼ˆ11-20ç•ªï¼‰- åˆç´šå…¨ç²å¾—å¾Œã«ã‚¢ãƒ³ãƒ­ãƒƒã‚¯
      { id: 11, name: "1000å›åˆä½“",       icon: "ğŸ’«", description: "1000å›åˆä½“ã«æˆåŠŸã—ãŸ",                    condition: "merge_1000",        unlocked: false, tier: "ä¸­ç´š" },
      { id: 12, name: "ãƒãƒ¼æ¶ˆã—30000",     icon: "ğŸš«ğŸ§¹", description: "ã‘ã—ã”ã‚€ã‚’ä½¿ã‚ãšã«30000ç‚¹ç²å¾—",         condition: "no_eraser_30000",   unlocked: false, tier: "ä¸­ç´š" },
      { id: 13, name: "ã‚¹ã‚³ã‚¢40000",       icon: "ğŸ¹", description: "ã‚¹ã‚³ã‚¢40000ç‚¹ã‚’é”æˆã—ãŸ",                  condition: "score_40000",       unlocked: false, tier: "ä¸­ç´š" },
      { id: 14, name: "ã‚­ãƒ³ã‚¯ãƒ500ç´¯è¨ˆ",   icon: "ğŸ§¡", description: "ã‚­ãƒ³ã‚¯ãƒãƒãƒ ã‚¹ã‚¿ãƒ¼ã‚’ç´¯è¨ˆ500åŒ¹ä½œã£ãŸ",      condition: "kinkuma_500",       unlocked: false, tier: "ä¸­ç´š" },
      { id: 15, name: "10åˆ†çµŒéï¼ˆ1å›ï¼‰",   icon: "â°", description: "ã‚²ãƒ¼ãƒ é–‹å§‹ã‹ã‚‰10åˆ†çµŒéã—ãŸ",               condition: "session_10min",     unlocked: false, tier: "ä¸­ç´š" },
      { id: 16, name: "10å›ãƒ—ãƒ¬ã‚¤",        icon: "ğŸ”„", description: "10å›ã‚²ãƒ¼ãƒ ã‚’ãƒ—ãƒ¬ã‚¤ã—ãŸ",                   condition: "game_10plays",      unlocked: false, tier: "ä¸­ç´š" },
      { id: 17, name: "ç´¯è¨ˆ30åˆ†",         icon: "â³", description: "ç´¯è¨ˆæ™‚é–“30åˆ†çµŒéã—ãŸ",                      condition: "total_time_30min",  unlocked: false, tier: "ä¸­ç´š" },
      { id: 18, name: "1åˆ†ã§10000",        icon: "âš¡", description: "1åˆ†ä»¥å†…ã«10000ç‚¹ç²å¾—",                     condition: "speed_10000_1min",  unlocked: false, tier: "ä¸­ç´š" },
      { id: 19, name: "ã‚¿ãƒƒãƒ—1000",        icon: "ğŸ‘†", description: "ç”»é¢ã‚’ç´¯è¨ˆ1000å›ã‚¿ãƒƒãƒ—ã—ãŸ",                condition: "tap_1000",          unlocked: false, tier: "ä¸­ç´š" },
      { id: 20, name: "ä¼èª¬Ã—4ï¼ˆ1å›ï¼‰",     icon: "ğŸ‘‘", description: "1å›ã®ã‚²ãƒ¼ãƒ ã§ä¼èª¬ãƒãƒ ã‚¹ã‚¿ãƒ¼ã‚’4åŒ¹ä½œã£ãŸ",   condition: "legendary_4_once",  unlocked: false, tier: "ä¸­ç´š" },
      // ä¸Šç´šç§°å·ï¼ˆ21-30ç•ªï¼‰- ä¸­ç´šå…¨ç²å¾—å¾Œã«ã‚¢ãƒ³ãƒ­ãƒƒã‚¯
      { id: 21, name: "5000å›åˆä½“",      icon: "ğŸ†", description: "5000å›åˆä½“ã«æˆåŠŸã—ãŸ", condition: "merge_5000", unlocked: false, tier: "ä¸Šç´š" },
      { id: 22, name: "ãƒãƒ¼æ¶ˆã—40000",    icon: "ğŸš«ğŸ§¹", description: "ã‘ã—ã”ã‚€ã‚’ä½¿ã‚ãšã«40000ç‚¹ç²å¾—", condition: "no_eraser_40000", unlocked: false, tier: "ä¸Šç´š" },
      { id: 23, name: "ã‚¹ã‚³ã‚¢50000", icon: "ğŸ¹", description: "ã‚¹ã‚³ã‚¢50000ç‚¹ã‚’é”æˆã—ãŸ",           condition: "score_50000", unlocked: false, tier: "ä¸Šç´š" },
      { id: 24, name: "ã‚­ãƒ³ã‚¯ãƒ1000ç´¯è¨ˆ",         icon: "â³", description: "ã‚­ãƒ³ã‚¯ãƒãƒãƒ ã‚¹ã‚¿ãƒ¼ã‚’ç´¯è¨ˆ1000åŒ¹ä½œã£ãŸ",          condition: "kinkuma_1000", unlocked: false, tier: "ä¸Šç´š" },
      { id: 25, name: "15åˆ†çµŒéï¼ˆ1å›ï¼‰",       icon: "ğŸ®", description: "ã‚²ãƒ¼ãƒ é–‹å§‹ã‹ã‚‰15åˆ†çµŒéã—ãŸ",                    condition: "session_15min", unlocked: false, tier: "ä¸Šç´š" },
      { id: 26, name: "20å›ãƒ—ãƒ¬ã‚¤",     icon: "ğŸ’¥", description: "20å›ã‚²ãƒ¼ãƒ ã‚’ãƒ—ãƒ¬ã‚¤ã—ãŸ",              condition: "game_20plays", unlocked: false, tier: "ä¸Šç´š" },
      { id: 27, name: "ç´¯è¨ˆ60åˆ†",       icon: "âš¡", description: "ç´¯è¨ˆæ™‚é–“60åˆ†çµŒéã—ãŸ",           condition: "total_time_60min", unlocked: false, tier: "ä¸Šç´š" },
      { id: 28, name: "1åˆ†ã§15000",    icon: "ğŸ‘‘", description: "1åˆ†ä»¥å†…ã«15000ç‚¹ç²å¾—",   condition: "speed_15000_1min", unlocked: false, tier: "ä¸Šç´š" },
      { id: 29, name: "ã‚¿ãƒƒãƒ—5000",     icon: "ğŸ›¡ï¸", description: "ç”»é¢ã‚’ç´¯è¨ˆ5000å›ã‚¿ãƒƒãƒ—ã—ãŸ",     condition: "tap_5000", unlocked: false, tier: "ä¸Šç´š" },
      { id: 30, name: "ä¼èª¬Ã—5ï¼ˆ1å›ï¼‰",     icon: "ğŸ›ï¸", description: "1å›ã®ã‚²ãƒ¼ãƒ ã§ä¼èª¬ãƒãƒ ã‚¹ã‚¿ãƒ¼ã‚’5åŒ¹ä½œã£ãŸ",            condition: "legendary_5_once", unlocked: false, tier: "ä¸Šç´š" },
    
];

    let titleStats = {
      totalHamsters: 0,
      totalMerges: 0,
      maxScore: 0,
      kinkumaCount: 0,
  gameStartTime: 0,
  pausedTime: 0,        // ä¸€æ™‚åœæ­¢ã®ç´¯ç©æ™‚é–“
  pauseStartTime: 0,    // ä¸€æ™‚åœæ­¢é–‹å§‹æ™‚åˆ»
      totalGamesPlayed: 0,
      syrianReached: false,
      fastestTo500: Infinity,
      fastestTo1000: Infinity,
      fastestTo3000: Infinity,
      fastestTo5000: Infinity,
      legendaryCount: 0,
      totalPlayTime: 0,
      longestSession: 0,
      goldenReached: false,
      eraserUsed: 0,
      totalTaps: 0,
      rareReached: false,
      hasChainCombo: false        // é€£ç¶šåˆä½“è¨˜éŒ²
    };

    function loadTitles() {
      const saved = localStorage.getItem('hamukororin-titles');
      if (saved) {
        try {
          const data = JSON.parse(saved);
          if (data.titles) titles = data.titles;
          if (data.stats) {
            // æ—¢å­˜ã®çµ±è¨ˆãƒ‡ãƒ¼ã‚¿ã¨ãƒãƒ¼ã‚¸ï¼ˆæ–°ã—ã„ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚‚ä¿æŒï¼‰
            titleStats = {
              totalHamsters: data.stats.totalHamsters || 0,
              totalMerges: data.stats.totalMerges || 0,
              maxScore: data.stats.maxScore || 0,
              kinkumaCount: data.stats.kinkumaCount || 0,
                gameStartTime: data.stats.gameStartTime || 0,
  pausedTime: data.stats.pausedTime || 0,
  pauseStartTime: data.stats.pauseStartTime || 0,
              totalGamesPlayed: data.stats.totalGamesPlayed || 0,
              syrianReached: data.stats.syrianReached || false,
              fastestTo500: data.stats.fastestTo500 || Infinity,
              fastestTo1000: data.stats.fastestTo1000 || Infinity,
              fastestTo3000: data.stats.fastestTo3000 || Infinity,
              fastestTo5000: data.stats.fastestTo5000 || Infinity,
              legendaryCount: data.stats.legendaryCount || 0,
              totalPlayTime: data.stats.totalPlayTime || 0,
              longestSession: data.stats.longestSession || 0,
              goldenReached: data.stats.goldenReached || false,
              eraserUsed: data.stats.eraserUsed || 0,
              totalTaps: data.stats.totalTaps || 0,
              rareReached: data.stats.rareReached || false,
              hasChainCombo: data.stats.hasChainCombo || false
            };
          }
        } catch(e) {
          console.log('Failed to load titles:', e);
        }
      }
    }

    function saveTitles() {
      try {
        const dataToSave = {
          titles: titles,
          stats: titleStats
        };
        localStorage.setItem('hamukororin-titles', JSON.stringify(dataToSave));
      } catch(e) {
        console.log('Failed to save titles:', e);
      }
    }

    function shadeColor(color, percent) {
      const R = parseInt(color.substring(1,3),16);
      const G = parseInt(color.substring(3,5),16);
      const B = parseInt(color.substring(5,7),16);
      const newR = parseInt(R * (100 + percent) / 100);
      const newG = parseInt(G * (100 + percent) / 100);
      const newB = parseInt(B * (100 + percent) / 100);
      return "#" + 
        (newR < 255 ? newR : 255).toString(16).padStart(2, '0') +
        (newG < 255 ? newG : 255).toString(16).padStart(2, '0') +
        (newB < 255 ? newB : 255).toString(16).padStart(2, '0');
    }

    function drawHamster(ctx, type, radius) {
      const color = hamsterColors[type] || '#FFB6C1';
      
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
      gradient.addColorStop(0, color);
      gradient.addColorStop(1, shadeColor(color, -20));
      ctx.fillStyle = gradient;
      ctx.strokeStyle = '#8B4513';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(0, 0, radius * 0.9, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // è€³
      ctx.fillStyle = shadeColor(color, -10);
      ctx.beginPath();
      ctx.arc(-radius * 0.6, -radius * 0.6, radius * 0.25, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(radius * 0.6, -radius * 0.6, radius * 0.25, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // è€³ã®ä¸­
      ctx.fillStyle = '#FF69B4';
      ctx.beginPath();
      ctx.arc(-radius * 0.6, -radius * 0.55, radius * 0.12, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(radius * 0.6, -radius * 0.55, radius * 0.12, 0, Math.PI * 2);
      ctx.fill();
      
      // ç›®
      ctx.fillStyle = '#000';
      ctx.beginPath(); 
      ctx.arc(-radius * 0.25, -radius * 0.2, radius * 0.08, 0, Math.PI * 2); 
      ctx.fill();
      ctx.beginPath(); 
      ctx.arc(radius * 0.25, -radius * 0.2, radius * 0.08, 0, Math.PI * 2); 
      ctx.fill();
      
      // å…‰
      ctx.fillStyle = '#FFF';
      ctx.beginPath();
      ctx.arc(-radius * 0.22, -radius * 0.23, radius * 0.03, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(radius * 0.22, -radius * 0.23, radius * 0.03, 0, Math.PI * 2);
      ctx.fill();
      
      // é¼»
      ctx.fillStyle = '#FF1493';
      ctx.beginPath(); 
      ctx.arc(0, radius * 0.05, radius * 0.05, 0, Math.PI * 2); 
      ctx.fill();
      
      // ã»ã£ãº
      ctx.fillStyle = 'rgba(255, 182, 193, 0.6)';
      ctx.beginPath();
      ctx.arc(-radius * 0.45, radius * 0.1, radius * 0.08, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(radius * 0.45, radius * 0.1, radius * 0.08, 0, Math.PI * 2);
      ctx.fill();
    }

    function initNextPreview() {
      nextCanvas = document.createElement('canvas');
      nextCanvas.width = 46;
      nextCanvas.height = 46;
      nextCanvas.style.borderRadius = '4px';
      nextCtx = nextCanvas.getContext('2d');
      nextPreview.innerHTML = '';
      nextPreview.appendChild(nextCanvas);
    }

    function updateNextPreview() {
      if (!nextCtx || !gameState.nextBall) return;
      
      nextCtx.fillStyle = '#74b9ff';
      nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
      
      const t = gameState.nextBall.type;
      const baseRadius = foodTypes[t].size;
      const scale = Math.min(20 / baseRadius, 1.2);
      const r = baseRadius * scale;
      
      nextCtx.save();
      nextCtx.translate(nextCanvas.width / 2, nextCanvas.height / 2);
      drawHamster(nextCtx, t, r);
      nextCtx.restore();
    }

    class Particle {
      constructor(x, y, type = 'sparkle') {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = (Math.random() - 0.5) * 8 - 2;
        this.life = 1.0;
        this.decay = Math.random() * 0.02 + 0.015;
        this.size = Math.random() * 4 + 2;
        this.type = type;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.3;
      }
      
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.1;
        this.vx *= 0.98;
        this.vy *= 0.98;
        this.life -= this.decay;
        this.rotation += this.rotationSpeed;
        return this.life > 0;
      }
      
      draw() {
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        if (this.type === 'sparkle') {
          ctx.fillStyle = `hsl(${45 + Math.sin(Date.now() * 0.01) * 15}, 80%, 70%)`;
          ctx.beginPath();
          const s = this.size * this.life;
          ctx.moveTo(0, -s);
          ctx.lineTo(s * 0.3, -s * 0.3);
          ctx.lineTo(s, 0);
          ctx.lineTo(s * 0.3, s * 0.3);
          ctx.lineTo(0, s);
          ctx.lineTo(-s * 0.3, s * 0.3);
          ctx.lineTo(-s, 0);
          ctx.lineTo(-s * 0.3, -s * 0.3);
          ctx.closePath();
          ctx.fill();
        }
        
        ctx.restore();
      }
    }

    function createMergeEffect(x, y, intensity = 15) {
      for (let i = 0; i < intensity; i++) {
        gameState.particles.push(new Particle(x, y, 'sparkle'));
      }
    }

    class Ball {
      constructor(x, y, type) {
        this.x = x; 
        this.y = y; 
        this.vx = 0; 
        this.vy = 0;
        this.type = type;
        this.radius = foodTypes[type].size;
        this.points = foodTypes[type].points;
        this.name = foodTypes[type].name;
        this.merged = false;
        this.dropTimer = 0;
        this.rotation = 0;
        this.rotationSpeed = 0;
      }
      
      update() {
        if (this.merged) return;
        this.dropTimer++;
        this.vy += gravity;
        this.vx *= 0.999;
        this.vy *= 0.999;
        this.rotationSpeed = this.vx * 0.05;
        this.rotation += this.rotationSpeed;
        this.rotationSpeed *= 0.95;
        this.x += this.vx; 
        this.y += this.vy;
        
        if (this.x - this.radius < 0) {
          this.x = this.radius; 
          this.vx *= -wallBounce; 
          this.vy += (Math.random() - .5);
        }
        if (this.x + this.radius > canvas.width) {
          this.x = canvas.width - this.radius; 
          this.vx *= -wallBounce; 
          this.vy += (Math.random() - .5);
        }
        if (this.y + this.radius > canvas.height) {
          this.y = canvas.height - this.radius; 
          this.vy *= -groundBounce; 
          this.vx *= friction;
        }
        this.checkCollisions();
      }
      
      checkCollisions() {
        for (const other of gameState.balls) {
          if (other === this || other.merged || this.merged) continue;
          const dx = other.x - this.x;
          const dy = other.y - this.y;
          const distance = Math.hypot(dx, dy);
          const minDistance = this.radius + other.radius;
          if (distance < minDistance) {
            if (this.type === other.type && this.type < foodTypes.length - 1) {
              this.merge(other);
            } else {
              const overlap = minDistance - distance;
              const nx = dx / (distance || 1);
              const ny = dy / (distance || 1);
              const sep = overlap * 0.6;
              this.x -= nx * sep; 
              this.y -= ny * sep;
              other.x += nx * sep; 
              other.y += ny * sep;
              const rvx = other.vx - this.vx;
              const rvy = other.vy - this.vy;
              const impulse = (rvx * nx + rvy * ny) * 0.8;
              this.vx += impulse * nx; 
              this.vy += impulse * ny;
              other.vx -= impulse * nx; 
              other.vy -= impulse * ny;
            }
          }
        }
      }
      
      merge(other) {
        const newType = this.type + 1;
        const newX = (this.x + other.x) / 2;
        const newY = (this.y + other.y) / 2;
        const newBall = new Ball(newX, newY, newType);
        newBall.vy = -0.8; 
        newBall.vx = (Math.random() - 0.5) * 1;
        
        createMergeEffect(newX, newY, 12 + this.type * 2);
        unlockedHamsters.add(newType);
        
        // ã‚ˆã‚ŠæŸ”è»Ÿãªé€£ç¶šåˆä½“åˆ¤å®š
        const timeSinceLastMerge = gameState.lastMergeTime ? Date.now() - gameState.lastMergeTime : Infinity;
        const timeSinceDrop = gameState.dropTimer > 0 ? (Date.now() - gameState.dropTimer) / 1000 : Infinity;
        
        if (timeSinceDrop < 10 || timeSinceLastMerge < 2000) { // 10ç§’ä»¥å†…ã®ãƒ‰ãƒ­ãƒƒãƒ— ã¾ãŸã¯ 2ç§’ä»¥å†…ã®é€£ç¶šåˆä½“
          gameState.comboCount++;
          gameState.lastMergeTime = Date.now();
          
          if (gameState.comboCount >= 2 && !titleStats.hasChainCombo) {
            titleStats.hasChainCombo = true;
            saveTitles();
            checkTitleUnlocks();
          }
        } else {
          gameState.comboCount = 1;
          gameState.lastMergeTime = Date.now();
        }
        
        // å„ç¨®çµ±è¨ˆæ›´æ–°
        if (newType === 2) { // ã‚­ãƒ³ã‚¯ãƒ
          titleStats.kinkumaCount++;
        }
        
        if (newType >= 6) { // ã‚·ãƒªã‚¢ãƒ³ä»¥ä¸Š
          titleStats.syrianReached = true;
        }
        
        if (newType >= 8) { // ã‚´ãƒ¼ãƒ«ãƒ‡ãƒ³ä»¥ä¸Š
          titleStats.goldenReached = true;
        }
        
        if (newType === 9) { // ãƒ¬ã‚¢ãƒãƒ ã‚¹ã‚¿ãƒ¼
          titleStats.rareReached = true;
        }
        
        if (newType === foodTypes.length - 1) { // ä¼èª¬
          gameState.legendaryCount++;
          titleStats.legendaryCount++;
        }
        
        buildLegend();
        updateTitleStats();
        titleStats.totalMerges++;
        
        // ã‚¹ãƒ”ãƒ¼ãƒ‰è¨˜éŒ²ãƒã‚§ãƒƒã‚¯ï¼ˆ500ç‚¹ã€1000ç‚¹ã€3000ç‚¹ï¼‰
if (titleStats.gameStartTime > 0) {
  const elapsed = getActualPlayTime();

          
          if (gameState.score >= 500 && elapsed < titleStats.fastestTo500) {
            titleStats.fastestTo500 = elapsed;
          }
          
          if (gameState.score >= 1000 && elapsed < titleStats.fastestTo1000) {
            titleStats.fastestTo1000 = elapsed;
          }
          
          if (gameState.score >= 3000 && elapsed < titleStats.fastestTo3000) {
            titleStats.fastestTo3000 = elapsed;
          }
          
          if (gameState.score >= 5000 && elapsed < titleStats.fastestTo5000) {
            titleStats.fastestTo5000 = elapsed;
          }
        }
        
        checkTitleUnlocks();
        
        this.merged = true; 
        other.merged = true;
        gameState.balls.push(newBall);
        gameState.score += newBall.points; 
        updateScore();
      }
      
      draw() {
        if (this.merged) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        drawHamster(ctx, this.type, this.radius);
        ctx.restore();
      }
    }

    function checkTitleUnlocks() {
      let newTitles = [];
      
      // åˆç´šç§°å·ã®ç²å¾—æ•°ã‚’ãƒã‚§ãƒƒã‚¯
      const beginnerTitles = titles.filter(t => t.tier === "åˆç´š");
      const unlockedBeginnerCount = beginnerTitles.filter(t => t.unlocked).length;
      const isIntermediateUnlocked = unlockedBeginnerCount === beginnerTitles.length;
            
      const intermediateTitles = titles.filter(t => t.tier === "ä¸­ç´š");
      const unlockedIntermediateCount = intermediateTitles.filter(t => t.unlocked).length;
      const isAdvancedUnlocked = isIntermediateUnlocked && unlockedIntermediateCount === intermediateTitles.length;

      titles.forEach(title => {
        if (!title.unlocked) {
          let shouldUnlock = false;
          
          // ä¸­ç´šç§°å·ã¯åˆç´šç§°å·ã‚’å…¨ã¦ç²å¾—ã—ãŸå ´åˆã®ã¿ãƒã‚§ãƒƒã‚¯
          if (title.tier === "ä¸­ç´š" && !isIntermediateUnlocked) {
            return; // åˆç´šæœªå®Œäº†ãªã®ã§ä¸­ç´šã¯ã‚¹ã‚­ãƒƒãƒ—
          }

          // ä¸Šç´šç§°å·ã¯ä¸­ç´šç§°å·ã‚’å…¨ã¦ç²å¾—ã—ãŸå ´åˆã®ã¿ãƒã‚§ãƒƒã‚¯
          if (title.tier === "ä¸Šç´š" && !isAdvancedUnlocked) {
            return; // ä¸­ç´šæœªå®Œäº†ãªã®ã§ä¸Šç´šã¯ã‚¹ã‚­ãƒƒãƒ—
          }
          
          switch (title.condition) {case 'tap_5000':
  shouldUnlock = (titleStats.totalTaps || 0) >= 5000;
  break;
case 'speed_15000_1min':
  const elapsed = getActualPlayTime ? getActualPlayTime() : 9999;
  shouldUnlock = !!(gameState && gameState.gameStarted && elapsed <= 60 && gameState.score >= 15000);
  break;
case 'total_time_60min':
  shouldUnlock = (titleStats.totalPlayTime || 0) >= 3600;
  break;
case 'game_20plays':
  shouldUnlock = (titleStats.totalGamesPlayed || 0) >= 20;
  break;
case 'no_eraser_40000':
  if (gameState && gameState.gameStarted) {
    shouldUnlock = (titleStats.noEraserUsed && gameState.score >= 40000);
  }
  break;
case 'merge_5000':
  shouldUnlock = (titleStats.totalMerges || 0) >= 5000;
  break;

            case 'legendary_5_once':
              shouldUnlock = (gameState.legendaryCount >= 5);
              break;

            case 'game_30plays':
              shouldUnlock = (titleStats.totalGamesPlayed >= 30);
              break;

            case 'kinkuma_1000':
              shouldUnlock = (titleStats.kinkumaCount >= 1000);
              break;

            case 'no_eraser_60000':
              shouldUnlock = (gameState.gameStarted && !sessionEraserUsed && gameState.score >= 60000);
              break;

            // åˆç´šç§°å·ã®æ¡ä»¶
            case 'merge_1000':
              shouldUnlock = titleStats.totalMerges >= 1000;
              break;
            case 'merge_100':
              shouldUnlock = titleStats.totalMerges >= 100;
              break;
              shouldUnlock = titleStats.totalMerges >= 50;
              break;
            case 'no_eraser_10000':
              shouldUnlock = (gameState.gameStarted && !sessionEraserUsed && gameState.score >= 10000);
              break;
              shouldUnlock = titleStats.hasChainCombo;
              break;
            case 'score_20000':
              shouldUnlock = titleStats.maxScore >= 20000;
              break;
              shouldUnlock = titleStats.maxScore >= 5000;
              break;
            case 'kinkuma_50':
              shouldUnlock = titleStats.kinkumaCount >= 50;
              break;
              shouldUnlock = titleStats.kinkumaCount >= 10;
              break;
case 'session_10min':
              shouldUnlock = (gameState.gameStarted && getActualPlayTime() >= 600);
              break;
            case 'time_5min':
  if (gameState.gameStarted && titleStats.gameStartTime > 0) {
    const elapsed = getActualPlayTime();
    shouldUnlock = elapsed >= 300;
  }
  break;
            case 'game_10plays':
              shouldUnlock = titleStats.totalGamesPlayed >= 10;
              break;
            case 'game_3plays':
              shouldUnlock = titleStats.totalGamesPlayed >= 3;
              break;
            case 'total_time_10min':
              shouldUnlock = titleStats.totalPlayTime >= 600; // 10åˆ†
              break;
            case 'speed_3000_1min':
              shouldUnlock = titleStats.fastestTo3000 <= 60; // 1åˆ†ä»¥å†…ã«3000ç‚¹
              break;
            case 'tap_200':
              shouldUnlock = titleStats.totalTaps >= 200;
              break;
              shouldUnlock = titleStats.totalTaps >= 100;
              break;
            case 'rare_hamster':
              shouldUnlock = titleStats.rareReached;
              break;
              
            // ä¸­ç´šç§°å·ã®æ¡ä»¶
            case 'kinkuma_500':
              shouldUnlock = titleStats.kinkumaCount >= 500;
              break;
            case 'hamster_100':
              shouldUnlock = titleStats.totalHamsters >= 100;
              break;
            case 'merge_1000':
              shouldUnlock = titleStats.totalMerges >= 1000;
              break;
            case 'merge_100':
              shouldUnlock = titleStats.totalMerges >= 100;
              break;
            case 'score_40000':
              shouldUnlock = titleStats.maxScore >= 40000;
              break;
            case 'score_10000':
              shouldUnlock = titleStats.maxScore >= 10000;
              break;
            case 'kinkuma_50':
              shouldUnlock = titleStats.kinkumaCount >= 50;
              break;
case 'session_10min':
  if (gameState.gameStarted && titleStats.gameStartTime > 0) {
    const elapsed = getActualPlayTime();
    shouldUnlock = elapsed >= 600; // 10åˆ†
  }
  break;
            case 'game_10plays':
              shouldUnlock = titleStats.totalGamesPlayed >= 10;
              break;
            case 'golden_reached':
              shouldUnlock = titleStats.goldenReached || false;
              break;
            case 'speed_1000':
              shouldUnlock = titleStats.fastestTo1000 <= 120; // 2åˆ†ä»¥å†…ã«1000ç‚¹
              break;
            case 'speed_10000_1min':
  {
    // 1åˆ†ä»¥å†…ã«ç¾åœ¨ã‚¹ã‚³ã‚¢10000åˆ°é”
    const elapsed = getActualPlayTime ? getActualPlayTime() : 9999;
    shouldUnlock = !!(gameState && gameState.gameStarted && elapsed <= 60 && gameState.score >= 10000);
  }
  break;
            case 'total_time_30min':
              shouldUnlock = titleStats.totalPlayTime >= 1800; // 30åˆ†
              break;
            case 'speed_5000_1min':
              shouldUnlock = titleStats.fastestTo5000 <= 60;
              break;
              shouldUnlock = titleStats.fastestTo5000 <= 120; // 2åˆ†ä»¥å†…ã«5000ç‚¹
              break;
            case 'legendary_2_once':
              shouldUnlock = (gameState.legendaryCount >= 2);
              break;
              shouldUnlock = titleStats.legendaryCount >= 1;
              break;
            case 'legendary_4_once':
              shouldUnlock = (gameState.legendaryCount >= 4);
              break;
            case 'legendary_3':
              shouldUnlock = titleStats.legendaryCount >= 3;
              break;
              case 'score_50000':
              shouldUnlock = gameState.score >= 50000;
              break;
            case 'score_80000':
              shouldUnlock = gameState.score >= 80000;
              break;
            case 'no_eraser_30000':
              shouldUnlock = (!sessionEraserUsed && gameState.score >= 30000);
              break;
            case 'combo_10':
              shouldUnlock = (gameState.maxCombo >= 10);
              break;
            case 'legendary_3_once':
              shouldUnlock = (gameState.legendaryCount >= 3);
              break;
            case 'merge_total_3000':
              shouldUnlock = (titleStats.totalMerges >= 3000);
              break;
            case 'speed_5000_90s':
              shouldUnlock = (titleStats.fastestTo5000 > 0 && titleStats.fastestTo5000 <= 90);
              break;
            case 'session_15min':
              shouldUnlock = (gameState.gameStarted && getActualPlayTime() >= 900);
              break;
            case 'no_eraser_legend':
              shouldUnlock = (!sessionEraserUsed && gameState.legendaryCount >= 1);
              break;
            case 'maxcombo_12':
              shouldUnlock = (gameState.maxCombo >= 12);
              break;
          }
          
          if (shouldUnlock) {
            title.unlocked = true;
            newTitles.push(title);
          }
        }
      });
      
      newTitles.forEach(title => {
        showTitleUnlocked(title);
      });
      
      saveTitles();
    }

    function updateTitleStats() {
      titleStats.totalHamsters++;
      
      if (gameState.score > titleStats.maxScore) {
        titleStats.maxScore = gameState.score;
      }
    }

    function showTitleUnlocked(title) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #FFD700, #FFA500);
        color: #8B4513;
        padding: 8px 12px;
        border-radius: 15px;
        font-weight: bold;
        z-index: 2000;
        box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);
        border: 1px solid #FFD700;
        text-align: center;
        font-size: 12px;
        max-width: 200px;
      `;
      notification.innerHTML = `
        <div style="display: flex; align-items: center; gap: 6px;">
          <span style="font-size: 16px;">${title.icon}</span>
          <div>
            <div style="font-size: 11px; opacity: 0.8;">ç§°å·ç²å¾—!</div>
            <div style="font-size: 12px; font-weight: bold;">${title.name}</div>
          </div>
        </div>
      `;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, 3000);
    }

function showTitles() {
  const list = document.getElementById('titleList');
  list.innerHTML = '';

  // æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯ã§é€²æ—åˆ¤å®š
  const beginnerTitles = titles.filter(t => t.tier === "åˆç´š");
  const intermediateTitles = titles.filter(t => t.tier === "ä¸­ç´š");
  const advancedTitles = titles.filter(t => t.tier === "ä¸Šç´š");

  const unlockedBeginnerCount = beginnerTitles.filter(t => t.unlocked).length;
  const unlockedIntermediateCount = intermediateTitles.filter(t => t.unlocked).length;

  const isIntermediateUnlocked = unlockedBeginnerCount === beginnerTitles.length;
  const isAdvancedUnlocked = isIntermediateUnlocked && unlockedIntermediateCount === intermediateTitles.length;

  // ä¸Šéƒ¨ã®æ¦‚è¦ã‚«ãƒ¼ãƒ‰ï¼ˆç·è¨ˆã®è¦‹ã›æ–¹ã¯æ—¢å­˜ã¨åŒã˜ã‚¤ãƒ¡ãƒ¼ã‚¸ï¼‰
  const header = document.createElement('div');
  header.style.cssText = `
    text-align: center;
    margin-bottom: 16px;
    padding: 16px;
    background: linear-gradient(135deg, #74b9ff, #0984e3);
    color: white;
    border-radius: 12px;
    font-weight: bold;
  `;
  header.innerHTML = `
    <div style="font-size: 18px; margin-bottom: 6px;">ç§°å·ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³</div>
    <div style="font-size: 14px;">
      åˆç´š: ${unlockedBeginnerCount}/${beginnerTitles.length} |
      ä¸­ç´š: ${unlockedIntermediateCount}/${intermediateTitles.length} |
      ä¸Šç´š: ${advancedTitles.filter(t=>t.unlocked).length}/${advancedTitles.length}
    </div>
  `;
  list.appendChild(header);

  // ---- åˆç´šï¼ˆãƒˆã‚°ãƒ«ãƒ»åˆæœŸã¯é–‰ï¼‰----
  list.appendChild(createToggleSection(
    `ğŸ¥‰ åˆç´šç§°å· (${unlockedBeginnerCount}/${beginnerTitles.length})`,
    false,
    (container) => {
      beginnerTitles.forEach(title => {
        container.appendChild(createTitleElement(title));
      });
    }
  ));

  // ---- ä¸­ç´šï¼ˆãƒˆã‚°ãƒ«ãƒ»åˆæœŸã¯é–‰ã€‚åˆç´šå…¨å–å¾—ã¾ã§ã¯ãƒ­ãƒƒã‚¯è¡¨ç¤ºï¼‰----
  list.appendChild(createToggleSection(
    isIntermediateUnlocked
      ? `ğŸ¥ˆ ä¸­ç´šç§°å· (${unlockedIntermediateCount}/${intermediateTitles.length})`
      : `ğŸ”’ ä¸­ç´šç§°å· - åˆç´šç§°å·ã‚’å…¨ã¦ç²å¾—ã™ã‚‹ã¨è§£æ”¾`,
    false,
    (container) => {
      intermediateTitles.forEach(title => {
        container.appendChild(createTitleElement(title, !isIntermediateUnlocked));
      });
    }
  ));

  // ---- ä¸Šç´šï¼ˆãƒˆã‚°ãƒ«ãƒ»åˆæœŸã¯é–‰ã€‚ä¸­ç´šå…¨å–å¾—ã¾ã§ã¯ãƒ­ãƒƒã‚¯è¡¨ç¤ºï¼‰----
  const unlockedAdvancedCount = advancedTitles.filter(t => t.unlocked).length;
  list.appendChild(createToggleSection(
    isAdvancedUnlocked
      ? `ğŸ¥‡ ä¸Šç´šç§°å· (${unlockedAdvancedCount}/${advancedTitles.length})`
      : `ğŸ”’ ä¸Šç´šç§°å· - ä¸­ç´šç§°å·ã‚’å…¨ã¦ç²å¾—ã™ã‚‹ã¨è§£æ”¾`,
    false,
    (container) => {
      advancedTitles.forEach(title => {
        container.appendChild(createTitleElement(title, !isAdvancedUnlocked));
      });
    }
  ));

  document.getElementById('titleModal').style.display = 'block';
  resizeGame();
}


    function createTitleElement(title, isLocked = false) {
      const item = document.createElement('div');
      const baseOpacity = isLocked ? 0.3 : (title.unlocked ? 1 : 0.4);
      
      item.style.cssText = `
        margin: 12px 0;
        padding: 16px;
        border-radius: 12px;
        border: 2px solid ${title.unlocked ? '#FFD700' : '#ddd'};
        background: ${title.unlocked 
          ? 'linear-gradient(135deg, #FFD70020, #FFA50020)' 
          : 'linear-gradient(135deg, #f8f9fa, #e9ecef)'};
        opacity: ${baseOpacity};
        display: flex;
        align-items: center;
        gap: 16px;
        position: relative;
      `;
      
      if (isLocked) {
        const lockIcon = document.createElement('div');
        lockIcon.style.cssText = 'position: absolute; top: 8px; right: 8px; font-size: 16px; color: #999;';
        lockIcon.textContent = 'ğŸ”’';
        item.appendChild(lockIcon);
      }
      
      const icon = document.createElement('div');
      icon.style.cssText = `
        font-size: 32px;
        width: 48px;
        height: 48px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        background: ${title.unlocked ? 'rgba(255, 215, 0, 0.2)' : 'rgba(0,0,0,0.1)'};
        opacity: ${title.unlocked ? '1' : '0.6'};
      `;
      icon.textContent = title.icon;
      
      const content = document.createElement('div');
      content.style.flex = '1';
      content.innerHTML = `
        <div style="font-weight: bold; color: #2d3436; margin-bottom: 4px; font-size: 16px; opacity: ${title.unlocked ? '1' : '0.7'};">
          ${title.name}
        </div>
        <div style="color: #636e72; font-size: 13px; opacity: ${title.unlocked ? '1' : '0.6'};">
          ${title.description}
        </div>
      `;
      
      const status = document.createElement('div');
      status.style.cssText = `
        text-align: center;
        font-size: 12px;
        font-weight: bold;
        color: ${title.unlocked ? '#00b894' : '#636e72'};
        opacity: ${title.unlocked ? '1' : '0.5'};
      `;
      status.textContent = isLocked ? 'ãƒ­ãƒƒã‚¯ä¸­' : (title.unlocked ? 'ç²å¾—æ¸ˆã¿' : 'æœªç²å¾—');
      
      item.appendChild(icon);
      item.appendChild(content);
      item.appendChild(status);
      
      return item;
    }
// === ãƒˆã‚°ãƒ«ä»˜ãã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆåˆç´š/ä¸­ç´š/ä¸Šç´šï¼‰ ===
// itemsRenderer: (containerEl) => void ã§ã€ä¸­èº«ã®DOMæ§‹ç¯‰ã‚’å§”ã­ã‚‹
function createToggleSection(titleText, initiallyOpen, itemsRenderer) {
  const section = document.createElement('div');
  section.className = 'toggle-section';
  if (initiallyOpen) section.classList.add('open'); // ä»Šå›ã¯å…¨ã¦é–‰ã˜ã‚‹ä»•æ§˜ãªã®ã§ false æ¨å¥¨

  const header = document.createElement('div');
  header.className = 'toggle-header';
  header.textContent = titleText + (initiallyOpen ? ' â–¼' : ' â–¶');

  const content = document.createElement('div');
  content.className = 'toggle-content';

  header.addEventListener('click', () => {
    const isOpen = section.classList.toggle('open');
    header.textContent = titleText + (isOpen ? ' â–¼' : ' â–¶');
  });

  // ä¸­èº«ã®æç”»
  itemsRenderer(content);

  section.appendChild(header);
  section.appendChild(content);
  return section;
}

    
    function hideTitles() {
      document.getElementById('titleModal').style.display = 'none';
      resizeGame();
    }

    function useEraser() {
      if (eraserCount <= 0 || gameState.gameOver || gameState.paused) return;
      
      if (eraserMode) {
        eraserMode = false;
        canvas.style.cursor = 'default';
      } else {
        eraserMode = true;
        sessionEraserUsed = true;
        canvas.style.cursor = 'crosshair';
      }
      updateEraserUI();
    }

    function updateEraserUI() {
      eraserElement.textContent = eraserCount;
      const eraserSlot = document.getElementById('item-eraser');
      
      if (eraserCount <= 0) {
        eraserSlot.classList.add('disabled');
      } else {
        eraserSlot.classList.remove('disabled');
      }
      
      // æ¶ˆã—ã‚´ãƒ ãƒ¢ãƒ¼ãƒ‰ãŒONã®æ™‚ã¯è¦‹ãŸç›®ã‚’å¤‰æ›´
      if (eraserMode) {
        eraserSlot.style.border = '3px solid #ff1744';
        eraserSlot.style.backgroundColor = '#ffebee';
        eraserSlot.style.transform = 'scale(1.1)';
        eraserSlot.style.boxShadow = '0 0 15px rgba(255, 23, 68, 0.5)';
      } else {
        eraserSlot.style.border = '2px solid #ddd';
        eraserSlot.style.backgroundColor = '#fff';
        eraserSlot.style.transform = 'scale(1)';
        eraserSlot.style.boxShadow = 'none';
      }
    }

    function initGame(){
  var hud=document.getElementById('playtimeHud'); if(hud){hud.style.display='none'; hud.textContent='';}

      gameState.balls = []; // æ—¢å­˜ã®ãƒœãƒ¼ãƒ«ã‚’å…¨ã¦ã‚¯ãƒªã‚¢
      gameState.particles = [];
      gameState.legendaryCount = 0;
      gameState.score = 0;
      gameState.gameOver = false;
      gameState.gameStarted = false;
      gameState.paused = false;
      gameState.scoreSaved = false; // ã‚¹ã‚³ã‚¢ä¿å­˜ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
      gameState.dropX = canvas.width / 2;
      
      // ã‚²ãƒ¼ãƒ é–‹å§‹å‰ãªã®ã§ã€ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ã®ãƒãƒ ã‚¹ã‚¿ãƒ¼ã®ã¿æº–å‚™
      gameState.currentBall = createRandomBall();
      gameState.nextBall = createRandomBall();
      
      eraserCount = 2;
      eraserMode = false;
      canvas.style.cursor = 'default';
      
      for (let i = 0; i < Math.min(5, foodTypes.length); i++) {
        unlockedHamsters.add(i);
      }
      
  updateScore();
  updateEraserUI();
  updateNextPreview();
  updatePlayTime(); // æ™‚é–“è¡¨ç¤ºã‚’åˆæœŸåŒ–æ™‚ã«æ›´æ–°
  const promo = document.getElementById('promoLinks'); if (promo) promo.style.display = 'block';
  resizeGame();
}

    function createRandomBall() {
      const randomType = Math.floor(Math.random() * Math.min(5, foodTypes.length));
      return { type: randomType };
    }

function startGame() {
  try{ startPlayTimer && startPlayTimer(); }catch(e){}
  gameState.gameStarted = true;
      sessionEraserUsed = false;
  titleStats.gameStartTime = Date.now();
  titleStats.pausedTime = 0;      // ä¸€æ™‚åœæ­¢æ™‚é–“ã‚’ãƒªã‚»ãƒƒãƒˆ
  titleStats.pauseStartTime = 0;  // ä¸€æ™‚åœæ­¢é–‹å§‹æ™‚åˆ»ã‚’ãƒªã‚»ãƒƒãƒˆ
  titleStats.totalGamesPlayed++;
      
      // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«æ–°ã—ã„ãƒãƒ ã‚¹ã‚¿ãƒ¼ã‚’ç”¨æ„ï¼ˆè‡ªå‹•è½ä¸‹ã—ãªã„ã‚ˆã†ã«ï¼‰
      gameState.currentBall = createRandomBall();
      gameState.nextBall = createRandomBall();
      updateNextPreview();
      
      document.getElementById('menuButtons').style.display = 'none';
      document.getElementById('gameButtons').style.display = 'flex';
      document.getElementById('gameControls').style.display = 'flex';
      const promo = document.getElementById('promoLinks'); if (promo) promo.style.display = 'none';
      resizeGame();
      
      checkTitleUnlocks();
    }

    function gameLoop() {
      ctx.fillStyle = '#74b9ff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // æ™‚é–“çµŒéã®ç§°å·ãƒã‚§ãƒƒã‚¯ï¼ˆã‚²ãƒ¼ãƒ ä¸­ã®ã¿ï¼‰
      if (gameState.gameStarted && !gameState.paused && !gameState.gameOver) {
        checkTitleUnlocks();
        updatePlayTime(); // ãƒ—ãƒ¬ã‚¤æ™‚é–“ã‚’æ›´æ–°
        if (scoreElement) renderScore();
      }
      
      if (!gameState.gameStarted) {
        drawStartScreen();
      } else if (gameState.paused) {
        drawPauseScreen();
      } else if (!gameState.gameOver) {
        checkGameOver();
        gameState.balls = gameState.balls.filter(b => !b.merged);
        for (const b of gameState.balls) { 
          b.update(); 
          b.draw(); 
        }
        
        gameState.particles = gameState.particles.filter(p => {
          p.update();
          p.draw();
          return p.life > 0;
        });
        
        if (gameState.currentBall) drawPreviewBall();
        
        // æ¶ˆã—ã‚´ãƒ ãƒ¢ãƒ¼ãƒ‰è¡¨ç¤º
        if (eraserMode) {
          ctx.save();
          ctx.fillStyle = 'rgba(255, 23, 68, 0.1)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // ä¸Šéƒ¨ã®é€šçŸ¥ãƒãƒ¼
          ctx.fillStyle = 'rgba(255, 23, 68, 0.9)';
          ctx.fillRect(0, 0, canvas.width, 50);
          
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 16px system-ui, Arial';
          ctx.textAlign = 'center';
          ctx.fillText('ğŸ§¹ æ¶ˆã—ã‚´ãƒ ãƒ¢ãƒ¼ãƒ‰', canvas.width / 2, 20);
          ctx.font = '12px system-ui, Arial';
          ctx.fillText('å‰Šé™¤ã—ãŸã„ãƒãƒ ã‚¹ã‚¿ãƒ¼ã‚’ã‚¯ãƒªãƒƒã‚¯', canvas.width / 2, 35);
          
          ctx.restore();
        }
      } else {
        for (const b of gameState.balls) { 
          b.draw(); 
        }
        drawGameOver();
      }
      
      requestAnimationFrame(gameLoop);
    
    }

    function drawPauseScreen() {
      gameState.balls = gameState.balls.filter(b => !b.merged);
      for (const b of gameState.balls) { 
        b.draw(); 
      }
      
      if (gameState.currentBall) drawPreviewBall();
      
      ctx.save();
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 28px system-ui, Arial';
      ctx.textAlign = 'center';
      ctx.fillText('ä¸€æ™‚åœæ­¢ä¸­', canvas.width / 2, canvas.height / 2 - 30);
      
      ctx.font = '14px system-ui, Arial';
      ctx.fillText('ãƒœã‚¿ãƒ³ã¾ãŸã¯Pã‚­ãƒ¼ã§å†é–‹', canvas.width / 2, canvas.height / 2 + 10);
      
      ctx.restore();
    }

    function drawStartScreen() {
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#74b9ff');
      gradient.addColorStop(1, '#0984e3');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.save();
      ctx.fillStyle = '#fff';
      ctx.strokeStyle = '#e17055';
      ctx.lineWidth = 2;
      ctx.font = 'bold 32px system-ui, Arial';
      ctx.textAlign = 'center';
      ctx.strokeText('ã¯ã‚€ã“ã‚ã‚Šã‚“', canvas.width / 2, Math.floor(canvas.height * 0.18));
      ctx.fillText('ã¯ã‚€ã“ã‚ã‚Šã‚“', canvas.width / 2, Math.floor(canvas.height * 0.18));
      
      ctx.font = '14px system-ui, Arial';
      ctx.fillStyle = '#ddd';
      ctx.fillText('å¯æ„›ã„ãƒãƒ ã‚¹ã‚¿ãƒ¼ã‚’åˆä½“ã•ã›ã‚ˆã†ï¼', canvas.width / 2, Math.floor(canvas.height * 0.26));
      
      const centerX = canvas.width / 2;
      const centerY = Math.floor(canvas.height * 0.55);
      
      ctx.translate(centerX, centerY);
      const mainRadius = Math.min(48, canvas.width * 0.12);
      drawHamster(ctx, 7, mainRadius);
      
      for (let i = 0; i < 5; i++) {
        const angle = (i * Math.PI * 2 / 5) + Date.now() * 0.001;
        const radius = Math.min(92, canvas.width * 0.24);
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        const smallRadius = Math.min(22, canvas.width * 0.055);
        
        ctx.save();
        ctx.translate(x, y);
        drawHamster(ctx, i, smallRadius);
        ctx.restore();
      }
      
      ctx.restore();
      
      const buttonY = Math.floor(canvas.height * 0.86);
      const buttonWidth = 160;
      const buttonHeight = 40;
      const buttonX = (canvas.width - buttonWidth) / 2;
      
      ctx.fillStyle = '#00b894';
      ctx.strokeStyle = '#00a085';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.roundRect(buttonX, buttonY, buttonWidth, buttonHeight, 20);
      ctx.fill();
      ctx.stroke();
      
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 16px system-ui, Arial';
      ctx.textAlign = 'center';
      ctx.fillText('ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ', canvas.width / 2, buttonY + 26);
      
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.font = '12px system-ui, Arial';
      ctx.fillText('â† â†’ ã§ç§»å‹•ã€â†“ ã§ãƒ‰ãƒ­ãƒƒãƒ—', canvas.width / 2, buttonY + 66);
    }

    function drawPreviewBall() {
      const t = gameState.currentBall.type;
      const r = foodTypes[t].size;
      const y = r + 10;
      ctx.save();
      ctx.globalAlpha = 0.75;
      ctx.translate(gameState.dropX, y);
      drawHamster(ctx, t, r);
      ctx.restore();
    }

    function checkGameOver() {
      const gameOverLine = 5;
      ctx.save();
      ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
      ctx.lineWidth = 3;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(0, gameOverLine);
      ctx.lineTo(canvas.width, gameOverLine);
      ctx.stroke();
      ctx.restore();
      
      for (const ball of gameState.balls) {
        if (ball.y - ball.radius < gameOverLine && ball.dropTimer > 60) {
          gameState.gameOver = true;
          break;
        }
      }
    }

    function drawGameOver() {
      // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã®æ™‚é–“è¨˜éŒ²æ›´æ–°
      if (!gameState.scoreSaved && gameState.score > 0) {
        try {
          const currentSessionTime = titleStats.gameStartTime > 0 ? 
            Math.floor((Date.now() - titleStats.gameStartTime) / 1000) : 0;
          
          // ç´¯è¨ˆãƒ—ãƒ¬ã‚¤æ™‚é–“ã¨æœ€é•·ã‚»ãƒƒã‚·ãƒ§ãƒ³æ™‚é–“ã‚’æ›´æ–°
          titleStats.totalPlayTime = (titleStats.totalPlayTime || 0) + currentSessionTime;
          if (currentSessionTime > (titleStats.longestSession || 0)) {
            titleStats.longestSession = currentSessionTime;
          }
          
          // ç§°å·çµ±è¨ˆã‚’ä¿å­˜
          saveTitles();
          
          const shouldSave = highScores.length < 5 || gameState.score > Math.min(...highScores);
          if (shouldSave) {
            saveHighScore(gameState.score);
          }
        } catch(e) {
          console.log('Error saving game over data:', e);
        }
        gameState.scoreSaved = true;
      }
      
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,.5)'; // èƒŒæ™¯ã‚’è–„ã‚ã«å¤‰æ›´
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      const isNewRecord = gameState.score > 0 && (highScores.length === 0 || gameState.score > highScores[0]);
      
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 24px system-ui, Arial';
      ctx.textAlign = 'center';
      
      if (isNewRecord && gameState.score > 0) {
        ctx.fillStyle = '#FFD700';
        ctx.fillText('æ–°è¨˜éŒ²é”æˆï¼', canvas.width / 2, canvas.height / 2 - 60);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 20px system-ui, Arial';
        ctx.fillText('ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼!', canvas.width / 2, canvas.height / 2 - 25);
      } else {
        ctx.fillText('ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼!', canvas.width / 2, canvas.height / 2 - 40);
      }
      
      ctx.font = '16px system-ui, Arial';
      ctx.fillText(`æœ€çµ‚ã‚¹ã‚³ã‚¢: ${gameState.score} ç‚¹`, canvas.width / 2, canvas.height / 2 - 5);
      ctx.fillText(`ä¼èª¬ã®ãƒãƒ ã‚¹ã‚¿ãƒ¼: ${gameState.legendaryCount} åŒ¹`, canvas.width / 2, canvas.height / 2 + 20);
      ctx.font = '12px system-ui, Arial';
      ctx.fillText('ãƒªã‚»ãƒƒãƒˆã§å†é–‹', canvas.width / 2, canvas.height / 2 + 46);
      ctx.restore();
    
  // --- Share Buttons (X / LINE) ---
  window.lastScore = gameState.score || 0;
  const btnW = Math.min(140, canvas.width * 0.38);
  const btnH = 44;
  const gap = 14;
  const baseY = Math.floor(canvas.height * 0.66);
  const xLeft = (canvas.width / 2) - (btnW + gap/2);
  const xRight = (canvas.width / 2) + (gap/2);

  // X button
  const xBtn = { x: xLeft, y: baseY, w: btnW, h: btnH };
  ctx.fillStyle = '#1DA1F2';
  ctx.fillRect(xBtn.x, xBtn.y, xBtn.w, xBtn.h);
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 16px system-ui, Arial';
  ctx.textAlign = 'center';
  ctx.fillText('Xã§ã‚·ã‚§ã‚¢', xBtn.x + xBtn.w/2, xBtn.y + 28);

  // LINE button
  const lineBtn = { x: xRight, y: baseY, w: btnW, h: btnH };
  ctx.fillStyle = '#06C755';
  ctx.fillRect(lineBtn.x, lineBtn.y, lineBtn.w, lineBtn.h);
  ctx.fillStyle = '#fff';
  ctx.fillText('LINEã§ã‚·ã‚§ã‚¢', lineBtn.x + lineBtn.w/2, lineBtn.y + 28);

  // Save hitboxes for click/touch
  window.shareButtons = { xBtn, lineBtn };
}

function togglePause() {
  if (!gameState.gameStarted || gameState.gameOver) return;
  
  gameState.paused = !gameState.paused;
  
  const pauseBtn = document.getElementById('pauseBtn');
  if (gameState.paused) {
    // ä¸€æ™‚åœæ­¢é–‹å§‹
    titleStats.pauseStartTime = Date.now();
    pauseBtn.innerHTML = 'â–¶ï¸ å†é–‹';
    pauseBtn.title = 'ä¸€æ™‚åœæ­¢ã‚’è§£é™¤ã—ã¦å†é–‹';
  } else {
    // ä¸€æ™‚åœæ­¢çµ‚äº† - åœæ­¢æ™‚é–“ã‚’ç´¯ç©
    if (titleStats.pauseStartTime > 0) {
      titleStats.pausedTime += Date.now() - titleStats.pauseStartTime;
      titleStats.pauseStartTime = 0;
    }
    pauseBtn.innerHTML = 'â¸ï¸ åœæ­¢';
    pauseBtn.title = 'ä¸€æ™‚åœæ­¢/å†é–‹';
  }
  
  if (gameState.paused && eraserMode) {
    eraserMode = false;
    canvas.style.cursor = 'default';
  }
}

    function updateScore(){ renderScore(); document.getElementById('highscore').textContent = highScores[0] || 0; }

    function saveHighScore(score) {
      highScores.push(score);
      highScores.sort((a, b) => b - a);
      highScores = highScores.slice(0, 5);
      localStorage.setItem('hamukororin-highscores', JSON.stringify(highScores));
      updateScore();
    }

    function formatTime(seconds) {
      if (seconds < 60) {
        return `${seconds}ç§’`;
      } else if (seconds < 3600) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return remainingSeconds > 0 ? `${minutes}åˆ†${remainingSeconds}ç§’` : `${minutes}åˆ†`;
      } else {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        return minutes > 0 ? `${hours}æ™‚é–“${minutes}åˆ†` : `${hours}æ™‚é–“`;
      }
    }

    function formatPlayTime(seconds) {
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = seconds % 60;
      return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
    }

function updatePlayTime() {
  const playtimeElement = document.getElementById('playtime');
  const timeSeparator = document.getElementById('time-separator');
  
  // ã‚²ãƒ¼ãƒ ä¸­ã®ã¿æ™‚é–“è¡¨ç¤ºï¼ˆã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ã¨ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ã§ã¯éè¡¨ç¤ºï¼‰
  if (gameState.gameStarted && !gameState.gameOver && titleStats.gameStartTime > 0) {
    const rawElapsed = Date.now() - titleStats.gameStartTime;
    const currentPausedTime = gameState.paused && titleStats.pauseStartTime > 0 
      ? Date.now() - titleStats.pauseStartTime 
      : 0;
    const totalPausedTime = titleStats.pausedTime + currentPausedTime;
    const actualPlayTime = Math.floor((rawElapsed - totalPausedTime) / 1000);
    
    playtimeElement.textContent = formatPlayTime(Math.max(0, actualPlayTime));
    playtimeElement.style.display='none';
    timeSeparator.style.display='none';
  } else {
    playtimeElement.style.display = 'none';
    timeSeparator.style.display = 'none';
  }
  // HUD mirror (independent of scoreboard visibility)
  (function(){
    var hud = document.getElementById('playtimeHud');
    if (!hud) return;
    var show = (gameState.gameStarted && !gameState.gameOver && titleStats.gameStartTime > 0);
    if (show) {
      hud.textContent = playtimeElement ? playtimeElement.textContent : '';
      hud.style.display = 'block';
    } else {
      hud.style.display = 'none';
    }
  })();

}
// å®Ÿéš›ã®ãƒ—ãƒ¬ã‚¤æ™‚é–“ã‚’å–å¾—ã™ã‚‹é–¢æ•°ï¼ˆä¸€æ™‚åœæ­¢æ™‚é–“ã‚’é™¤å¤–ï¼‰
function getActualPlayTime() {
  if (!titleStats.gameStartTime) return 0;
  
  const rawElapsed = Date.now() - titleStats.gameStartTime;
  const currentPausedTime = gameState.paused && titleStats.pauseStartTime > 0 
    ? Date.now() - titleStats.pauseStartTime 
    : 0;
  const totalPausedTime = titleStats.pausedTime + currentPausedTime;
  
  return Math.floor((rawElapsed - totalPausedTime) / 1000);
}
    function showHighScores() {
      const list = document.getElementById('highScoreList');
      list.innerHTML = '';
      
      // ãƒ—ãƒ¬ã‚¤çµ±è¨ˆæƒ…å ±
      const statsHeader = document.createElement('div');
      statsHeader.style.cssText = `
        text-align: center;
        margin-bottom: 20px;
        padding: 16px;
        background: linear-gradient(135deg, #74b9ff, #0984e3);
        color: white;
        border-radius: 12px;
        font-weight: bold;
      `;
      statsHeader.innerHTML = `
        <div style="font-size: 18px; margin-bottom: 12px;">ğŸ“Š ãƒ—ãƒ¬ã‚¤çµ±è¨ˆ</div>
        <div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 10px;">
          <div style="flex: 1; min-width: 120px;">
            <div style="font-size: 24px; color: #FFD700;">${titleStats.totalGamesPlayed}</div>
            <div style="font-size: 12px; opacity: 0.9;">ç·ãƒ—ãƒ¬ã‚¤å›æ•°</div>
          </div>
          <div style="flex: 1; min-width: 120px;">
            <div style="font-size: 16px; color: #FFD700;">${formatTime(titleStats.totalPlayTime)}</div>
            <div style="font-size: 12px; opacity: 0.9;">ç´¯è¨ˆãƒ—ãƒ¬ã‚¤æ™‚é–“</div>
          </div>
          <div style="flex: 1; min-width: 120px;">
            <div style="font-size: 16px; color: #FFD700;">${titleStats.longestSession > 0 ? formatTime(titleStats.longestSession) : 'è¨˜éŒ²ãªã—'}</div>
            <div style="font-size: 12px; opacity: 0.9;">æœ€é•·ã‚»ãƒƒã‚·ãƒ§ãƒ³</div>
          </div>
        </div>
      `;
      list.appendChild(statsHeader);
      
      // ãƒã‚¤ã‚¹ã‚³ã‚¢è¡¨ç¤º
      const scoresHeader = document.createElement('div');
      scoresHeader.style.cssText = 'font-size: 16px; font-weight: bold; color: #e17055; margin: 20px 0 10px; text-align: center;';
      scoresHeader.textContent = 'ğŸ† ãƒã‚¤ã‚¹ã‚³ã‚¢ãƒ©ãƒ³ã‚­ãƒ³ã‚°';
      list.appendChild(scoresHeader);
      
      if (highScores.length === 0) {
        const noScores = document.createElement('div');
        noScores.style.cssText = 'padding: 20px; color: #666; font-size: 14px; text-align: center;';
        noScores.textContent = 'ã¾ã ã‚¹ã‚³ã‚¢ãŒè¨˜éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼';
        list.appendChild(noScores);
      } else {
        const medals = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰', 'ğŸ…', 'ğŸ†'];
        const colors = ['#FFD700', '#C0C0C0', '#CD7F32', '#87CEEB', '#FF69B4'];
        
        for (let i = 0; i < Math.min(highScores.length, 5); i++) {
          const score = highScores[i];
          const item = document.createElement('div');
          item.style.cssText = `
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            padding: 12px 20px; 
            margin: 8px 0; 
            background: linear-gradient(135deg, ${colors[i]}20, ${colors[i]}10); 
            border: 2px solid ${colors[i]}; 
            border-radius: 10px; 
            font-size: 16px; 
            font-weight: bold;
          `;
          
          item.innerHTML = `
            <span>${medals[i]} ${i + 1}ä½</span>
            <span style="color: #e17055;">${score.toLocaleString()}ç‚¹</span>
          `;
          
          list.appendChild(item);
        }
      }
      
      document.getElementById('highScoreModal').style.display = 'block';
      resizeGame();
    }

    function hideHighScores() {
      document.getElementById('highScoreModal').style.display = 'none';
      resizeGame();
    }

    function buildLegend() {
      const grid = document.getElementById('legendGrid');
      grid.innerHTML = '';
      
      const description = document.createElement('div');
      description.style.cssText = 'font-size: 12px; color: #666; margin-bottom: 10px; text-align: center;';
      description.textContent = 'åŒã˜ãƒãƒ ã‚¹ã‚¿ãƒ¼åŒå£«ã‚’åˆä½“ã•ã›ã‚‹ã¨æ¬¡ã®ãƒãƒ ã‚¹ã‚¿ãƒ¼ã«é€²åŒ–ï¼';
      grid.appendChild(description);
      
      for (let i = 0; i < foodTypes.length; i++) {
        const t = foodTypes[i];
        const item = document.createElement('div');
        item.className = 'legend-item';
        
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        canvas.className = 'legend-thumb';
        const ctx = canvas.getContext('2d');
        
        ctx.save();
        ctx.translate(16, 16);
        drawHamster(ctx, i, 14);
        ctx.restore();
        
        const span = document.createElement('span');
        span.className = 'legend-name';
        span.textContent = `${i+1}. ${t.name}`;
        
        item.appendChild(canvas);
        item.appendChild(span);
        grid.appendChild(item);
        
        // æœ€å¾Œã®ãƒãƒ ã‚¹ã‚¿ãƒ¼ä»¥å¤–ã«ä¸‹çŸ¢å°ã‚’è¿½åŠ 
        if (i < foodTypes.length - 1) {
          const arrow = document.createElement('div');
          arrow.style.cssText = `
            text-align: center;
            font-size: 20px;
            color: #e17055;
            margin: 5px 0;
            font-weight: bold;
          `;
          arrow.textContent = 'â†“';
          grid.appendChild(arrow);
        }
      }
      
      // æˆ»ã‚‹ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
      const backButton = document.createElement('div');
      backButton.style.cssText = 'text-align: center; margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee;';
      backButton.innerHTML = '<button class="btn" onclick="hideLegend()" style="background: #e17055; padding: 8px 16px;">ğŸ“± ã‚²ãƒ¼ãƒ ã«æˆ»ã‚‹</button>';
      grid.appendChild(backButton);
    }

    function moveLeft() {
      if (gameState.gameOver || gameState.paused || eraserMode || !gameState.gameStarted) return;
      const r = foodTypes[gameState.currentBall.type].size;
      gameState.dropX = Math.max(r, gameState.dropX - 30);
    }
    
    function moveRight() {
      if (gameState.gameOver || gameState.paused || eraserMode || !gameState.gameStarted) return;
      const r = foodTypes[gameState.currentBall.type].size;
      gameState.dropX = Math.min(canvas.width - r, gameState.dropX + 30);
    }
    
    function drop() {
      if (gameState.gameOver || gameState.paused || !gameState.currentBall || eraserMode || !gameState.gameStarted) return;
      
      // ã‚²ãƒ¼ãƒ é–‹å§‹ç›´å¾Œã®èª¤æ“ä½œé˜²æ­¢ï¼ˆ500mså¾…æ©Ÿï¼‰
      if (titleStats.gameStartTime > 0 && Date.now() - titleStats.gameStartTime < 500) {
        return;
      }
      
      const t = gameState.currentBall.type;
      const r = foodTypes[t].size;
      const b = new Ball(gameState.dropX, r + 5, t);
      gameState.balls.push(b);
      gameState.currentBall = gameState.nextBall;
      gameState.nextBall = createRandomBall();
      updateNextPreview();
      updateTitleStats();
      checkTitleUnlocks();
    }
    
    function resetGame() {
  try{ stopPlayTimer && stopPlayTimer(); }catch(e){} 
      // ãƒªã‚»ãƒƒãƒˆå‰ã«æ™‚é–“è¨˜éŒ²ã‚’æ›´æ–°
      if (gameState.gameStarted && titleStats.gameStartTime > 0) {
        try {
          const currentSessionTime = Math.floor((Date.now() - titleStats.gameStartTime) / 1000);
          
          // ç´¯è¨ˆãƒ—ãƒ¬ã‚¤æ™‚é–“ã¨æœ€é•·ã‚»ãƒƒã‚·ãƒ§ãƒ³æ™‚é–“ã‚’æ›´æ–°
          titleStats.totalPlayTime = (titleStats.totalPlayTime || 0) + currentSessionTime;
          if (currentSessionTime > (titleStats.longestSession || 0)) {
            titleStats.longestSession = currentSessionTime;
          }
          
          // ç§°å·çµ±è¨ˆã‚’ä¿å­˜
          saveTitles();
        } catch(e) {
          console.log('Error saving reset data:', e);
        }
      }
      
  gameState.paused = false;
  
  const pauseBtn = document.getElementById('pauseBtn');
  pauseBtn.innerHTML = 'â¸ï¸ åœæ­¢';
  pauseBtn.title = 'ä¸€æ™‚åœæ­¢/å†é–‹';
  
  document.getElementById('gameButtons').style.display = 'none';
  document.getElementById('menuButtons').style.display = 'flex';
  document.getElementById('gameControls').style.display = 'none';
  
  initGame();
  updatePlayTime(); // ãƒªã‚»ãƒƒãƒˆå¾Œã«æ™‚é–“è¡¨ç¤ºã‚’åˆæœŸåŒ–
  gameLoop();
}

    function showLegend() { 
      buildLegend();
      document.getElementById('legendModal').style.display = 'block';
      resizeGame(); 
    }
    
    function hideLegend() { 
      document.getElementById('legendModal').style.display = 'none';
      resizeGame(); 
    }

    function showHelp() { 
      document.getElementById('helpModal').style.display = 'block'; 
    }
    
    function hideHelp() { 
      document.getElementById('helpModal').style.display = 'none'; 
    }

    document.addEventListener('keydown', (e) => {
      if (!gameState.gameStarted) {
        if (e.key === ' ' || e.key === 'Enter') {
          startGame();
        }
        return;
      }
      
      switch (e.key) {
        case 'ArrowLeft': 
        case 'a': 
        case 'A': 
          moveLeft(); 
          break;
        case 'ArrowRight': 
        case 'd': 
        case 'D': 
          moveRight(); 
          break;
        case 'ArrowDown': 
        case ' ': 
        case 's': 
        case 'S': 
          drop(); 
          break;
        case 'r': 
        case 'R': 
          resetGame(); 
          break;
        case 'p':
        case 'P':
          togglePause();
          break;
      }
    });

    canvas.addEventListener('click', (e) => {
      // ã‚¿ãƒƒãƒ—æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
      titleStats.totalTaps = (titleStats.totalTaps || 0) + 1;
      
      if (!gameState.gameStarted) {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvas.width / rect.width);
        const y = (e.clientY - rect.top) * (canvas.height / rect.height);
        
        const buttonY = Math.floor(canvas.height * 0.86);
        const buttonWidth = 160;
        const buttonHeight = 40;
        const buttonX = (canvas.width - buttonWidth) / 2;
        
        if (x >= buttonX && x <= buttonX + buttonWidth && 
            y >= buttonY && y <= buttonY + buttonHeight) {
          startGame();
        }
        return;
      }
      
      // æ¶ˆã—ã‚´ãƒ ãƒ¢ãƒ¼ãƒ‰ã§ãƒãƒ ã‚¹ã‚¿ãƒ¼å‰Šé™¤
      if (eraserMode && gameState.gameStarted && !gameState.gameOver && !gameState.paused) {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvas.width / rect.width);
        const y = (e.clientY - rect.top) * (canvas.height / rect.height);
        
        for (let i = gameState.balls.length - 1; i >= 0; i--) {
          const ball = gameState.balls[i];
          const distance = Math.hypot(ball.x - x, ball.y - y);
          if (distance < ball.radius) {
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åŠ¹æœ
            for (let j = 0; j < 10; j++) {
              gameState.particles.push(new Particle(ball.x, ball.y, 'sparkle'));
            }
            // ãƒãƒ ã‚¹ã‚¿ãƒ¼å‰Šé™¤
            gameState.balls.splice(i, 1);
            eraserCount--;
            titleStats.eraserUsed = (titleStats.eraserUsed||0)+1;
            sessionEraserUsed = true;
            updateEraserUI();
            
            // æ¶ˆã—ã‚´ãƒ ãƒ¢ãƒ¼ãƒ‰çµ‚äº†
            eraserMode = false;
            canvas.style.cursor = 'default';
            
            // é‡è¦ï¼šã“ã“ã§returnã—ã¦æ–°ã—ã„ãƒãƒ ã‚¹ã‚¿ãƒ¼ãŒè½ã¡ãªã„ã‚ˆã†ã«ã™ã‚‹
            return;
          }
        }
      }
    });

    // ã‚¿ãƒƒãƒæ“ä½œ
    let touchActive = false;
    let touchStartTime = 0;
    let touchMoved = false;

    canvas.addEventListener('touchstart', function(e) {
      e.preventDefault();
      
      // ã‚¿ãƒƒãƒ—æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
      titleStats.totalTaps = (titleStats.totalTaps || 0) + 1;
      
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const touchX = touch.clientX - rect.left;
      const touchY = touch.clientY - rect.top;
      
      const canvasX = touchX * (canvas.width / rect.width);
      const canvasY = touchY * (canvas.height / rect.height);
      
      touchActive = true;
      touchStartTime = Date.now();
      touchMoved = false;
      
      if (!gameState.gameStarted) {
        const buttonY = Math.floor(canvas.height * 0.86);
        const buttonWidth = 160;
        const buttonHeight = 40;
        const buttonX = (canvas.width - buttonWidth) / 2;
        
        if (canvasX >= buttonX && canvasX <= buttonX + buttonWidth && 
            canvasY >= buttonY && canvasY <= buttonY + buttonHeight) {
          startGame();
        }
        return;
      }
      
      // æ¶ˆã—ã‚´ãƒ ãƒ¢ãƒ¼ãƒ‰ã§ã®å‡¦ç†
      if (eraserMode && gameState.gameStarted && !gameState.gameOver && !gameState.paused) {
        for (let i = gameState.balls.length - 1; i >= 0; i--) {
          const ball = gameState.balls[i];
          const distance = Math.hypot(ball.x - canvasX, ball.y - canvasY);
          if (distance < ball.radius) {
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åŠ¹æœ
            for (let j = 0; j < 10; j++) {
              gameState.particles.push(new Particle(ball.x, ball.y, 'sparkle'));
            }
            // ãƒãƒ ã‚¹ã‚¿ãƒ¼å‰Šé™¤
            gameState.balls.splice(i, 1);
            eraserCount--;
            titleStats.eraserUsed = (titleStats.eraserUsed||0)+1;
            sessionEraserUsed = true;
            updateEraserUI();
            
            // æ¶ˆã—ã‚´ãƒ ãƒ¢ãƒ¼ãƒ‰çµ‚äº†
            eraserMode = false;
            canvas.style.cursor = 'default';
            
            // é‡è¦ï¼šã‚¿ãƒƒãƒæ“ä½œã‚‚ç„¡åŠ¹åŒ–
            touchActive = false;
            return;
          }
        }
        return;
      }
      
      if (gameState.gameStarted && !gameState.paused && !gameState.gameOver && gameState.currentBall && !eraserMode) {
        const r = foodTypes[gameState.currentBall.type].size;
        gameState.dropX = Math.max(r, Math.min(canvas.width - r, canvasX));
      }
    }, { passive: false });

    canvas.addEventListener('touchmove', function(e) {
      e.preventDefault();
      
      if (!touchActive) return;
      
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const touchX = touch.clientX - rect.left;
      
      const canvasX = touchX * (canvas.width / rect.width);
      
      touchMoved = true;
      
      if (gameState.gameStarted && !gameState.paused && !gameState.gameOver && !eraserMode && gameState.currentBall) {
        const r = foodTypes[gameState.currentBall.type].size;
        gameState.dropX = Math.max(r, Math.min(canvas.width - r, canvasX));
      }
    }, { passive: false });

    canvas.addEventListener('touchend', function(e) {
      e.preventDefault();
      
      if (!touchActive) return;
      
      const touchDuration = Date.now() - touchStartTime;
      const gameStartDelay = gameState.gameStarted && (Date.now() - gameStartTime < 500);
      
      if (!gameStartDelay && gameState.gameStarted && !gameState.paused && !gameState.gameOver && !eraserMode) {
        if (touchMoved || (!touchMoved && touchDuration < 250)) {
          drop();
        }
      }
      
      touchActive = false;
      touchMoved = false;
    }, { passive: false });

    // åˆæœŸåŒ–
    initNextPreview();
    buildLegend();
    initGame();
    gameLoop();
  
    document.addEventListener('DOMContentLoaded', () => {
      initNextPreview();
      initGame();
      resizeGame();
      gameLoop();
    });
    

// PWA install with fallback
let deferredPrompt;
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
});
(() => {
  const btn = document.getElementById('installBtn');
  if (btn) {
    btn.addEventListener('click', async () => {
      if (deferredPrompt) {
        deferredPrompt.prompt();
        const c = await deferredPrompt.userChoice;
        if (c.outcome === 'accepted') deferredPrompt = null;
      } else {
        alert('ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰ã€Œãƒ›ãƒ¼ãƒ ç”»é¢ã«è¿½åŠ ã€ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚\nï¼ˆChrome: å³ä¸Šã®ï¸™â†’ ãƒ›ãƒ¼ãƒ ç”»é¢ã«è¿½åŠ ï¼‰');
      }
    });
  }
})();

// --- Share Buttons: open X/LINE when tapped ---
if (!window.__shareClickInit) {
  window.__shareClickInit = true;
  canvas.addEventListener('click', function(e) {
    if (!window.shareButtons || !gameState.gameOver) return;
    const {x, y} = screenXYToCanvas(e);
    const sb = window.shareButtons;
    const pageUrl = encodeURIComponent(location.href);
    const text = encodeURIComponent(`ã¯ã‚€ã“ã‚ã‚Šã‚“ã§ ${window.lastScore} ç‚¹ã¨ã£ãŸã‚ˆï¼ #ã¯ã‚€ã“ã‚ã‚Šã‚“ #hamuchira #ãƒãƒ ã‚¹ã‚¿ãƒ¼ã‚²ãƒ¼ãƒ `);
    if (x >= sb.xBtn.x && x <= sb.xBtn.x + sb.xBtn.w && y >= sb.xBtn.y && y <= sb.xBtn.y + sb.xBtn.h) {
      window.open(`https://x.com/intent/tweet?text=${encodeURIComponent(`ã¯ã‚€ã“ã‚ã‚Šã‚“ã§ ${window.lastScore} ç‚¹ã¨ã£ãŸã‚ˆï¼

ãƒãƒ ã‚¹ã‚¿ãƒ¼ã‚’ã“ã‚ã“ã‚ã—ã¦å¤§ããã™ã‚‹ã‚²ãƒ¼ãƒ ã€ãœã²éŠã‚“ã§ã¿ã¦ã­ï¼
${decodeURIComponent(pageUrl)}
#ã¯ã‚€ã“ã‚ã‚Šã‚“ #ã¯ã‚€ãƒãƒ© #ãƒãƒ ã‚¹ã‚¿ãƒ¼`)}` , "_blank");
      e.preventDefault();
      return;
    }
    if (x >= sb.lineBtn.x && x <= sb.lineBtn.x + sb.lineBtn.w && y >= sb.lineBtn.y && y <= sb.lineBtn.y + sb.lineBtn.h) {
      window.open(`https://social-plugins.line.me/lineit/share?url=${pageUrl}%0A${text}`, "_blank");
      e.preventDefault();
      return;
    }
  }, {passive:false});
  canvas.addEventListener('touchstart', function(e) {
    if (!window.shareButtons || !gameState.gameOver) return;
    const {x, y} = screenXYToCanvas(e);
    const sb = window.shareButtons;
    const pageUrl = encodeURIComponent(location.href);
    const text = encodeURIComponent(`ã¯ã‚€ã“ã‚ã‚Šã‚“ã§ ${window.lastScore} ç‚¹ã¨ã£ãŸã‚ˆï¼ #ã¯ã‚€ã“ã‚ã‚Šã‚“ #hamuchira #ãƒãƒ ã‚¹ã‚¿ãƒ¼ã‚²ãƒ¼ãƒ `);
    if (x >= sb.xBtn.x && x <= sb.xBtn.x + sb.xBtn.w && y >= sb.xBtn.y && y <= sb.xBtn.y + sb.xBtn.h) {
      window.open(`https://x.com/intent/tweet?text=${encodeURIComponent(`ã¯ã‚€ã“ã‚ã‚Šã‚“ã§ ${window.lastScore} ç‚¹ã¨ã£ãŸã‚ˆï¼

ãƒãƒ ã‚¹ã‚¿ãƒ¼ã‚’ã“ã‚ã“ã‚ã—ã¦å¤§ããã™ã‚‹ã‚²ãƒ¼ãƒ ã€ãœã²éŠã‚“ã§ã¿ã¦ã­ï¼
${decodeURIComponent(pageUrl)}
#ã¯ã‚€ã“ã‚ã‚Šã‚“ #ã¯ã‚€ãƒãƒ© #ãƒãƒ ã‚¹ã‚¿ãƒ¼`)}` , "_blank");
      e.preventDefault();
      return;
    }
    if (x >= sb.lineBtn.x && x <= sb.lineBtn.x + sb.lineBtn.w && y >= sb.lineBtn.y && y <= sb.lineBtn.y + sb.lineBtn.h) {
      window.open(`https://social-plugins.line.me/lineit/share?url=${pageUrl}%0A${text}`, "_blank");
      e.preventDefault();
      return;
    }
  }, {passive:false});
}
</script>

<script>

// ===== Hold-to-Repeat (é€£å°„) Utility =====
(function(){
  // Global singleton to prevent duplicate timers across buttons
  if (!window.__autoRepeat) {
    window.__autoRepeat = {
      holdTimer: null,
      repeatTimer: null,
      token: 0,
      stop(){
        this.token++;
        if (this.holdTimer){ clearTimeout(this.holdTimer); this.holdTimer = null; }
        if (this.repeatTimer){ clearInterval(this.repeatTimer); this.repeatTimer = null; }
      },
      start(action, thresholdMs, intervalMs){
        this.stop();
        const myToken = ++this.token;
        this.holdTimer = setTimeout(() => {
          if (this.token !== myToken) return;
          this.repeatTimer = setInterval(() => {
            if (this.token !== myToken) return;
            try { action(); } catch(e){ /* swallow */ }
          }, intervalMs);
        }, thresholdMs);
      }
    };
    // Safety stops
    for (const ev of ['visibilitychange','blur','pagehide']) {
      window.addEventListener(ev, ()=>window.__autoRepeat.stop(), {passive:true});
    }
  }

  function attachHoldRepeat(button, action, thresholdMs=5000, intervalMs=120){
    if (!button) return;
    const start = (e) => {
      e.preventDefault && e.preventDefault();
      // single tap action
      action();
      // begin global hold->repeat
      window.__autoRepeat.start(action, thresholdMs, intervalMs);
    };
    const stop = () => window.__autoRepeat.stop();

    // Pointer eventsï¼ˆãƒã‚¦ã‚¹ãƒ»ã‚¿ãƒƒãƒä¸¡å¯¾å¿œï¼‰
    button.addEventListener('pointerdown', start, {passive:false});
    for (const ev of ['pointerup','pointerleave','pointercancel','pointerout']) {
      button.addEventListener(ev, stop, {passive:true});
    }
    // Prevent context menu on long press (mobile)
    button.addEventListener('contextmenu', (e)=>e.preventDefault());
  }

  window.addEventListener('DOMContentLoaded', () => {
    attachHoldRepeat(document.getElementById('btnLeft'), ()=>{ moveLeft && moveLeft(); }, 5000, 80);
    attachHoldRepeat(document.getElementById('btnRight'), ()=>{ moveRight && moveRight(); }, 5000, 80);
    attachHoldRepeat(document.getElementById('btnDrop'), ()=>{ drop && drop(); }, 5000, 120);
  
    // Canvas long-press: start repeat after threshold without firing immediately
    const canvas = document.getElementById('gameCanvas') || window.canvas;
    if (canvas) {
      const startCanvas = (e) => {
        if (!window.__autoRepeat) return;
        if (e && e.preventDefault) e.preventDefault();
        // don't fire immediately; only schedule repeat after threshold
        window.__autoRepeat.stop();
        const myToken = ++window.__autoRepeat.token;
        window.__autoRepeat.holdTimer = setTimeout(() => {
          if (window.__autoRepeat.token !== myToken) return;
          window.__autoRepeat.repeatTimer = setInterval(() => {
            if (window.__autoRepeat.token !== myToken) return;
            try { if (typeof drop === 'function') drop(); } catch(e){}
          }, 120);
        }, 5000);
      };
      const stopCanvas = () => window.__autoRepeat && window.__autoRepeat.stop();
      canvas.addEventListener('pointerdown', startCanvas, {passive:false});
      for (const ev of ['pointerup','pointerleave','pointercancel','pointerout']) {
        canvas.addEventListener(ev, stopCanvas, {passive:true});
      }
    }
  });})();
// ===== /Hold-to-Repeat =====

</script>

<!-- Tap long-press (5s) to auto-drop -->
<script>
// (removed canvas long-press auto-drop to prevent duplicate timers)

</script>


    <script>
    // === ãƒˆã‚°ãƒ«ä»˜ãã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆåˆç´š/ä¸­ç´š/ä¸Šç´šï¼‰ + é–‹é–‰çŠ¶æ…‹ã‚’ä¿å­˜ ===
    // key: 'beginner' | 'intermediate' | 'advanced'
    function createToggleSection(titleText, initiallyOpen, itemsRenderer, key) {
      try {
        const LS_KEY = 'titleToggle.' + key;
        const saved = localStorage.getItem(LS_KEY);
        const startOpen = saved === null ? initiallyOpen : saved === 'open';

        const section = document.createElement('div');
        section.className = 'toggle-section';
        if (startOpen) section.classList.add('open');

        const header = document.createElement('div');
        header.className = 'toggle-header';
        header.setAttribute('role', 'button');
        header.setAttribute('tabindex', '0');
        header.textContent = titleText + (startOpen ? ' â–¼' : ' â–¶');

        const content = document.createElement('div');
        content.className = 'toggle-content';

        const toggle = () => {
          const isOpen = section.classList.toggle('open');
          header.textContent = titleText + (isOpen ? ' â–¼' : ' â–¶');
          try { localStorage.setItem(LS_KEY, isOpen ? 'open' : 'close'); } catch(e){}
          // ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³ï¼ˆä»»æ„ãƒ»åŒæ™‚ã«1ã¤ã ã‘é–‹ãï¼‰:
          if (section.classList.contains('open')) {
            document.querySelectorAll('.toggle-section.open').forEach(s => { if (s !== section) s.classList.remove('open'); });
          }
        };

        header.addEventListener('click', toggle);
        header.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggle(); }
        });

        itemsRenderer(content);

        section.appendChild(header);
        section.appendChild(content);
        return section;
      } catch (err) {
        console.error('createToggleSection error:', err);
      }
    }

    // === showTitles ã‚’å¾Œå‹ã¡ã§ä¸Šæ›¸ãï¼ˆæ—¢å­˜ã‚ˆã‚Šå¾Œã«å®šç¾©ã™ã‚‹ã“ã¨ã§å·®ã—æ›¿ãˆï¼‰===
    if (typeof showTitles === 'function') {
      const _orig_createTitleElement = (typeof createTitleElement === 'function') ? createTitleElement : null;

      window.showTitles = function showTitles() {
        try {
          const list = document.getElementById('titleList');
          if (!list) return;
          list.innerHTML = '';

          const tiers = { beginner: 'åˆç´š', intermediate: 'ä¸­ç´š', advanced: 'ä¸Šç´š' };
          const beginnerTitles = (window.titles || []).filter(t => t.tier === tiers.beginner);
          const intermediateTitles = (window.titles || []).filter(t => t.tier === tiers.intermediate);
          const advancedTitles = (window.titles || []).filter(t => t.tier === tiers.advanced);

          const unlockedBeginnerCount = beginnerTitles.filter(t => t.unlocked).length;
          const unlockedIntermediateCount = intermediateTitles.filter(t => t.unlocked).length;
          const unlockedAdvancedCount = advancedTitles.filter(t => t.unlocked).length;

          const isIntermediateUnlocked = beginnerTitles.length > 0 && unlockedBeginnerCount === beginnerTitles.length;
          const isAdvancedUnlocked = isIntermediateUnlocked && intermediateTitles.length > 0 && unlockedIntermediateCount === intermediateTitles.length;

          // æ¦‚è¦ã‚«ãƒ¼ãƒ‰
          const header = document.createElement('div');
          header.style.cssText = 'text-align:center;margin-bottom:16px;padding:16px;background:linear-gradient(135deg,#74b9ff,#0984e3);color:#fff;border-radius:12px;font-weight:bold;';
          header.innerHTML = '<div style="font-size:18px;margin-bottom:6px;">ç§°å·ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³</div>' +
                             '<div style="font-size:14px;">' +
                             'åˆç´š: ' + unlockedBeginnerCount + '/' + beginnerTitles.length + ' | ' +
                             'ä¸­ç´š: ' + unlockedIntermediateCount + '/' + intermediateTitles.length + ' | ' +
                             'ä¸Šç´š: ' + unlockedAdvancedCount + '/' + advancedTitles.length +
                             '</div>';
          list.appendChild(header);

          // åˆç´š
          list.appendChild(createToggleSection(
            'ğŸ¥‰ åˆç´šç§°å· (' + unlockedBeginnerCount + '/' + beginnerTitles.length + ')',
            false,
            function(container) {
              beginnerTitles.forEach(function(title) {
                container.appendChild(_orig_createTitleElement ? _orig_createTitleElement(title) : document.createTextNode(title.name || ''));
              });
            },
            'beginner'
          ));

          // ä¸­ç´š
          list.appendChild(createToggleSection(
            isIntermediateUnlocked
              ? 'ğŸ¥ˆ ä¸­ç´šç§°å· (' + unlockedIntermediateCount + '/' + intermediateTitles.length + ')'
              : 'ğŸ”’ ä¸­ç´šç§°å· - åˆç´šç§°å·ã‚’å…¨ã¦ç²å¾—ã™ã‚‹ã¨è§£æ”¾',
            false,
            function(container) {
              intermediateTitles.forEach(function(title) {
                container.appendChild(_orig_createTitleElement ? _orig_createTitleElement(title, !isIntermediateUnlocked) : document.createTextNode(title.name || ''));
              });
            },
            'intermediate'
          ));

          // ä¸Šç´š
          list.appendChild(createToggleSection(
            isAdvancedUnlocked
              ? 'ğŸ¥‡ ä¸Šç´šç§°å· (' + unlockedAdvancedCount + '/' + advancedTitles.length + ')'
              : 'ğŸ”’ ä¸Šç´šç§°å· - ä¸­ç´šç§°å·ã‚’å…¨ã¦ç²å¾—ã™ã‚‹ã¨è§£æ”¾',
            false,
            function(container) {
              advancedTitles.forEach(function(title) {
                container.appendChild(_orig_createTitleElement ? _orig_createTitleElement(title, !isAdvancedUnlocked) : document.createTextNode(title.name || ''));
              });
            },
            'advanced'
          ));

          const modal = document.getElementById('titleModal');
          if (modal) modal.style.display = 'block';
          if (typeof resizeGame === 'function') resizeGame();
        } catch (err) {
          console.error('showTitles override error:', err);
        }
      };
    }
    </script>
    

<script>
// --- Robust fallback: event delegation for toggling ---
document.addEventListener('click', function(e){
  var header = e.target.closest && e.target.closest('.toggle-header');
  if (!header) return;
  var section = header.parentElement;
  if (!section || !section.classList.contains('toggle-section')) return;
  var text = header.textContent.replace(' â–¼','').replace(' â–¶','');
  var nowOpen = !section.classList.contains('open');
  section.classList.toggle('open', nowOpen);
  header.textContent = text + (nowOpen ? ' â–¼' : ' â–¶');
});

document.addEventListener('keydown', function(e){
  var header = e.target.closest && e.target.closest('.toggle-header');
  if (!header) return;
  if (e.key === 'Enter' || e.key === ' ') {
    e.preventDefault();
    header.click();
  }
});
</script>


<script>
(function(){
  // Patch createToggleSection if present
  var oldCreate = window.createToggleSection;
  window.createToggleSection = function(titleText, initiallyOpen, itemsRenderer, key){
    // Fallback if no oldCreate
    var section = document.createElement('div');
    section.className = 'toggle-section';
    if (initiallyOpen) section.classList.add('open');

    var header = document.createElement('div');
    header.className = 'toggle-header';
    header.setAttribute('role', 'button');
    header.setAttribute('tabindex', '0');
    header.textContent = titleText + (initiallyOpen ? ' â–¼' : ' â–¶');

    var content = document.createElement('div');
    content.className = 'toggle-content';

    var render = function(){
      // clear
      while (content.firstChild) content.removeChild(content.firstChild);
      itemsRenderer(content);
      if (!content.children.length){
        var hint = document.createElement('div');
        hint.className = 'empty-hint';
        hint.textContent = 'ã¾ã ç§°å·ã¯ã‚ã‚Šã¾ã›ã‚“';
        content.appendChild(hint);
      }
    };
    render();

    var toggle = function(){
      var nowOpen = !section.classList.contains('open');
      section.classList.toggle('open', nowOpen);
      header.textContent = titleText + (nowOpen ? ' â–¼' : ' â–¶');
    };

    header.addEventListener('click', toggle);
    header.addEventListener('keydown', function(e){
      if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggle(); }
    });

    section.appendChild(header);
    section.appendChild(content);
    return section;
  };

  // Event delegation (safety net)
  document.addEventListener('click', function(e){
    var header = e.target.closest && e.target.closest('.toggle-header');
    if (!header) return;
    var section = header.parentElement;
    if (!section || !section.classList.contains('toggle-section')) return;
    var base = header.textContent.replace(' â–¼','').replace(' â–¶','');
    var nowOpen = !section.classList.contains('open');
    section.classList.toggle('open', nowOpen);
    header.textContent = base + (nowOpen ? ' â–¼' : ' â–¶');
  });

  document.addEventListener('keydown', function(e){
    var header = e.target.closest && e.target.closest('.toggle-header');
    if (!header) return;
    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); header.click(); }
  });
})();
</script>


<script>
// --- Override showTitles to read titles even if declared with 'let' (not on window) ---
(function(){
  if (typeof createTitleElement !== 'function' || typeof createToggleSection !== 'function') return;
  const _createTitle = createTitleElement;

  window.showTitles = function showTitles(){
    try {
      const list = document.getElementById('titleList');
      if (!list) return;
      list.innerHTML = '';

      // titles ãŒ window ç›´ä¸‹ã§ãªãã¦ã‚‚æ‹¾ã†ï¼ˆlet ã§å®£è¨€ã•ã‚ŒãŸå ´åˆã«å¯¾å¿œï¼‰
      const T = (typeof titles !== 'undefined' && titles) ? titles : (window.titles || []);

      const beginnerTitles = T.filter(t => t.tier === 'åˆç´š');
      const intermediateTitles = T.filter(t => t.tier === 'ä¸­ç´š');
      const advancedTitles = T.filter(t => t.tier === 'ä¸Šç´š');

      const unlockedBeginnerCount = beginnerTitles.filter(t => t.unlocked).length;
      const unlockedIntermediateCount = intermediateTitles.filter(t => t.unlocked).length;
      const unlockedAdvancedCount = advancedTitles.filter(t => t.unlocked).length;

      const isIntermediateUnlocked = beginnerTitles.length > 0 && unlockedBeginnerCount === beginnerTitles.length;
      const isAdvancedUnlocked = isIntermediateUnlocked && intermediateTitles.length > 0 && unlockedIntermediateCount === intermediateTitles.length;

      // æ¦‚è¦ã‚«ãƒ¼ãƒ‰
      const header = document.createElement('div');
      header.style.cssText = 'text-align:center;margin-bottom:16px;padding:16px;background:linear-gradient(135deg,#74b9ff,#0984e3);color:#fff;border-radius:12px;font-weight:bold;';
      header.innerHTML = '<div style="font-size:18px;margin-bottom:6px;">ç§°å·ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³</div>' +
                         '<div style="font-size:14px;">' +
                         'åˆç´š: ' + unlockedBeginnerCount + '/' + beginnerTitles.length + ' | ' +
                         'ä¸­ç´š: ' + unlockedIntermediateCount + '/' + intermediateTitles.length + ' | ' +
                         'ä¸Šç´š: ' + unlockedAdvancedCount + '/' + advancedTitles.length +
                         '</div>';
      list.appendChild(header);

      // åˆç´š
      list.appendChild(createToggleSection(
        'ğŸ¥‰ åˆç´šç§°å· (' + unlockedBeginnerCount + '/' + beginnerTitles.length + ')',
        false,
        function(container) {
          beginnerTitles.forEach(function(title) {
            container.appendChild(_createTitle(title));
          });
        },
        'beginner'
      ));

      // ä¸­ç´š
      list.appendChild(createToggleSection(
        isIntermediateUnlocked
          ? 'ğŸ¥ˆ ä¸­ç´šç§°å· (' + unlockedIntermediateCount + '/' + intermediateTitles.length + ')'
          : 'ğŸ”’ ä¸­ç´šç§°å· - åˆç´šç§°å·ã‚’å…¨ã¦ç²å¾—ã™ã‚‹ã¨è§£æ”¾',
        false,
        function(container) {
          intermediateTitles.forEach(function(title) {
            container.appendChild(_createTitle(title, !isIntermediateUnlocked));
          });
        },
        'intermediate'
      ));

      // ä¸Šç´š
      list.appendChild(createToggleSection(
        isAdvancedUnlocked
          ? 'ğŸ¥‡ ä¸Šç´šç§°å· (' + unlockedAdvancedCount + '/' + advancedTitles.length + ')'
          : 'ğŸ”’ ä¸Šç´šç§°å· - ä¸­ç´šç§°å·ã‚’å…¨ã¦ç²å¾—ã™ã‚‹ã¨è§£æ”¾',
        false,
        function(container) {
          advancedTitles.forEach(function(title) {
            container.appendChild(_createTitle(title, !isAdvancedUnlocked));
          });
        },
        'advanced'
      ));

      const modal = document.getElementById('titleModal');
      if (modal) modal.style.display = 'block';
      if (typeof resizeGame === 'function') resizeGame();
    } catch (err) {
      console.error('showTitles override error (scoping):', err);
    }
  };
})();
</script>


<script>
// ---- Ensure HUD always shows "ãƒ—ãƒ¬ã‚¤æ™‚é–“:mm:ss" during play and pause ----
(function(){
  function normalizeHud(){
    var el = document.getElementById('playtimeHud');
    if(!el) return;
    var txt = (el.textContent || '').trim();
    // If it already starts with "ãƒ—ãƒ¬ã‚¤æ™‚é–“", leave as-is but normalize spacing
    if (txt.startsWith('ãƒ—ãƒ¬ã‚¤æ™‚é–“')) {
      // unify "ãƒ—ãƒ¬ã‚¤æ™‚é–“: mm:ss" -> "ãƒ—ãƒ¬ã‚¤æ™‚é–“:mm:ss"
      el.textContent = txt.replace(/^ãƒ—ãƒ¬ã‚¤æ™‚é–“\s*:\s*/, 'ãƒ—ãƒ¬ã‚¤æ™‚é–“:');
      return;
    }
    // If it's like "m:ss" or "mm:ss", prepend label and zero-pad minutes
    var m = txt.match(/^(\d{1,2}):(\d{2})$/);
    if (m) {
      var mm = ('0' + m[1]).slice(-2);
      var ss = m[2];
      el.textContent = 'ãƒ—ãƒ¬ã‚¤æ™‚é–“:' + mm + ':' + ss;
      return;
    }
    // If it's only seconds "12" -> 00:12
    var s2 = txt.match(/^(\d{1,3})$/);
    if (s2) {
      var sec = parseInt(s2[1], 10) || 0;
      var mm2 = ('0' + Math.floor(sec/60)).slice(-2);
      var ss2 = ('0' + (sec%60)).slice(-2);
      el.textContent = 'ãƒ—ãƒ¬ã‚¤æ™‚é–“:' + mm2 + ':' + ss2;
      return;
    }
  }

  // Poll periodically to catch both playing and paused states
  setInterval(normalizeHud, 200);
  // Also try to fix style to keep it visible above overlays
  var style = document.createElement('style');
  style.textContent = '#playtimeHud{ z-index: 10000 !important; pointer-events:none; }';
  document.head.appendChild(style);
})();
</script>


<script>
/* ---- Force format playtime to "ãƒ—ãƒ¬ã‚¤æ™‚é–“:mm:ss" no matter who updates it ---- */
(function(){
  function pad2(n){ return (n<10?'0':'') + n; }

  function normalizeText(txt){
    txt = (txt||'').trim();
    // cases: "m:ss", "mm:ss", "sss", "ãƒ—ãƒ¬ã‚¤æ™‚é–“: m:ss"
    var m = txt.match(/^(\d{1,2}):(\d{2})$/);
    if (m) return 'ãƒ—ãƒ¬ã‚¤æ™‚é–“:' + pad2(parseInt(m[1],10)) + ':' + m[2];
    var s = txt.match(/^(\d{1,4})$/);
    if (s){
      var sec = parseInt(s[1],10)||0;
      return 'ãƒ—ãƒ¬ã‚¤æ™‚é–“:' + pad2(Math.floor(sec/60)) + ':' + pad2(sec%60);
    }
    // Already labeled? normalize spaces
    if (/^ãƒ—ãƒ¬ã‚¤æ™‚é–“\s*:/.test(txt)) {
      var parts = txt.replace(/^ãƒ—ãƒ¬ã‚¤æ™‚é–“\s*:\s*/, '').split(':');
      if (parts.length===2){
        return 'ãƒ—ãƒ¬ã‚¤æ™‚é–“:' + pad2(parseInt(parts[0],10)||0) + ':' + pad2(parseInt(parts[1],10)||0);
      }
      return 'ãƒ—ãƒ¬ã‚¤æ™‚é–“:' + txt.replace(/^ãƒ—ãƒ¬ã‚¤æ™‚é–“\s*:\s*/,'').trim();
    }
    return null; // unknown format
  }

  function fixElement(el){
    if (!el) return;
    var newText = normalizeText(el.textContent);
    if (newText && el.textContent !== newText){
      el.textContent = newText;
    }
  }

  function tick(){
    var el = document.getElementById('playtimeHud');
    if (el) fixElement(el);
  }

  // MutationObserver on the HUD element & its parent (in case inner text nodes change)
  var obs = new MutationObserver(function(){
    tick();
  });

  function setupObserver(){
    var el = document.getElementById('playtimeHud');
    if (el){
      try { obs.observe(el, {characterData:true, childList:true, subtree:true}); } catch(e){}
      // Also observe parent to catch replacements
      if (el.parentNode) {
        try { obs.observe(el.parentNode, {childList:true, subtree:true}); } catch(e){}
      }
    }
  }

  // Kickers
  document.addEventListener('DOMContentLoaded', function(){
    setupObserver(); tick();
  });
  window.addEventListener('load', function(){ setupObserver(); tick(); });

  // Periodic safety net
  setInterval(function(){ setupObserver(); tick(); }, 200);
})();
</script>


<script>
/* --- Hide "ã‚¹ã‚³ã‚¢: n" on start screen, keep only "ãƒã‚¤ã‚¹ã‚³ã‚¢: n" --- */
(function(){
  const origDrawStart = (typeof drawStartScreen === 'function') ? drawStartScreen : null;
  if (!origDrawStart) return;
  window.drawStartScreen = function(){
    // Call original drawing
    origDrawStart();
    try {
      const el = document.getElementById('scoreDisplay');
      if (!el) return;
      // If "ã‚¹ã‚³ã‚¢: X | ãƒã‚¤ã‚¹ã‚³ã‚¢: Y" â†’ keep only "ãƒã‚¤ã‚¹ã‚³ã‚¢: Y"
      const m = el.textContent.match(/ãƒã‚¤ã‚¹ã‚³ã‚¢[:ï¼š]\s*\d+/);
      if (m) {
        el.textContent = m[0];
      }
    } catch(e){ console.warn('start score hide patch:', e); }
  };
})();
</script>


<script>
(function(){
  function isStartScreen(){
    // heuristics: start button exists and game not running/pause overlay absent
    return !!(document.getElementById('startButton') || document.querySelector('.start-screen'));
  }
  function fixStartScore(){
    var el = document.getElementById('scoreDisplay');
    if (!el) return;
    var txt = (el.textContent || '');
    // pick only "ãƒã‚¤ã‚¹ã‚³ã‚¢: n"
    var m = txt.match(/ãƒã‚¤ã‚¹ã‚³ã‚¢[:ï¼š]\s*\d+/);
    if (m && isStartScreen()){
      el.textContent = m[0];
    }
  }
  // Observe changes to scoreDisplay text
  function setup(){
    var el = document.getElementById('scoreDisplay');
    if (!el) return;
    try {
      var mo = new MutationObserver(function(){ fixStartScore(); });
      mo.observe(el, {childList:true,characterData:true,subtree:true});
    }catch(e){}
    fixStartScore();
  }
  document.addEventListener('DOMContentLoaded', setup);
  window.addEventListener('load', setup);
  // safety net
  setInterval(fixStartScore, 200);
})();
</script>


<script>
/* --- Start screen: hide only "ã‚¹ã‚³ã‚¢: n" even if element id is unknown --- */
(function(){
  function isStartScreen(){
    // heuristics: start button or "ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ" button visible
    const startBtn = document.getElementById('startButton') || Array.from(document.querySelectorAll('button, a'))
      .find(el => /ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ/.test(el.textContent || ''));
    return !!startBtn;
  }

  function fixGenericScoreLine(root){
    const candidates = root ? root.querySelectorAll('div, p, span, h1, h2, h3') : document.querySelectorAll('div, p, span, h1, h2, h3');
    const re = /ã‚¹ã‚³ã‚¢\s*:\s*\d+\s*\|\s*ãƒã‚¤ã‚¹ã‚³ã‚¢\s*:\s*(\d+)/;
    for (const el of candidates){
      const txt = (el.textContent || '').trim();
      const m = txt.match(re);
      if (m) {
        el.textContent = 'ãƒã‚¤ã‚¹ã‚³ã‚¢: ' + m[1];
        return true;
      }
    }
    return false;
  }

  // Observe body for any changes while on start screen
  const mo = new MutationObserver((mutations) => {
    if (!isStartScreen()) return;
    for (const m of mutations){
      const target = m.target.nodeType === 1 ? m.target : null;
      if (target) {
        if (fixGenericScoreLine(target)) break;
      }
    }
  });

  function setup(){
    try { mo.observe(document.body, {childList:true, subtree:true, characterData:true}); } catch(e){}
    // initial sweep
    if (isStartScreen()) { fixGenericScoreLine(document); }
  }

  document.addEventListener('DOMContentLoaded', setup);
  window.addEventListener('load', setup);
  // safety net
  setInterval(()=>{ if (isStartScreen()) fixGenericScoreLine(document); }, 300);
})();
</script>


<script>
(function(){
  if (typeof drawStartScreen === 'function') {
    const orig = drawStartScreen;
    window.drawStartScreen = function(){
      orig();
      try {
        const el = document.getElementById('scoreDisplay');
        if (el) {
          const m = (el.textContent || '').match(/ãƒã‚¤ã‚¹ã‚³ã‚¢[:ï¼š]\s*\d+/);
          if (m) {
            el.textContent = m[0]; // ãƒã‚¤ã‚¹ã‚³ã‚¢ã ã‘æ®‹ã™
          }
        }
      } catch(e){ console.warn('start score rewrite error', e); }
    };
  }
})();
</script>


<script>
/* --- Start screen: hide only "ã‚¹ã‚³ã‚¢", show only "ãƒã‚¤ã‚¹ã‚³ã‚¢" --- */
(function(){
  function isStartScreen(){
    // start button heuristic
    if (document.getElementById('startButton')) return true;
    const btn = Array.from(document.querySelectorAll('button, a')).find(el => /ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ/.test(el.textContent||''));
    return !!btn;
  }
  function setHighScoreOnly(highScore){
    const el = document.getElementById('scoreDisplay');
    if (!el) return;
    el.textContent = 'ãƒã‚¤ã‚¹ã‚³ã‚¢: ' + (highScore ?? 0);
  }
  // 1) Prefer overriding the canonical updater if it exists
  if (typeof window.updateScoreDisplay === 'function') {
    const _orig = window.updateScoreDisplay;
    window.updateScoreDisplay = function(score, highScore){
      if (isStartScreen()) {
        setHighScoreOnly(highScore);
      } else {
        _orig.apply(this, arguments);
      }
    };
  } else {
    // 2) Fallback: observe text changes and rewrite on start screen
    function rewriteIfNeeded(){
      if (!isStartScreen()) return;
      const el = document.getElementById('scoreDisplay');
      if (!el) return;
      const txt = (el.textContent || '');
      const m = txt.match(/ãƒã‚¤ã‚¹ã‚³ã‚¢[:ï¼š]\s*(\d+)/);
      if (m) {
        el.textContent = 'ãƒã‚¤ã‚¹ã‚³ã‚¢: ' + m[1];
      }
    }
    const mo = new MutationObserver(rewriteIfNeeded);
    window.addEventListener('load', function(){
      const el = document.getElementById('scoreDisplay');
      if (el) mo.observe(el, {childList:true, characterData:true, subtree:true});
      rewriteIfNeeded();
    });
    setInterval(rewriteIfNeeded, 300);
  }
})();
</script>


<script>
/* --- Start screen only: hide the "ã‚¹ã‚³ã‚¢:" block without breaking game updates --- */
(function(){
  function ensureScoreBlockWrapper(){
    const box = document.getElementById('gameScore');
    if (!box) return;
    if (box.querySelector('#scoreBlock')) return; // already wrapped
    // Wrap "ã‚¹ã‚³ã‚¢: <span id="score">...</span> | " into #scoreBlock
    const html = box.innerHTML;
    const replaced = html.replace(/ã‚¹ã‚³ã‚¢:\s*<span id="score">[\s\S]*?<\/span>\s*\|\s*/,
                                  '<span id="scoreBlock">$&</span>');
    if (replaced !== html) box.innerHTML = replaced;
  }

  function setScoreBlockVisible(visible){
    const sb = document.getElementById('scoreBlock');
    if (sb) sb.style.display = visible ? '' : 'none';
  }

  function onTick(){
    ensureScoreBlockWrapper();
    try {
      const isStart = (typeof gameState === 'object') ? !gameState.gameStarted : !!(document.getElementById('startButton') || document.querySelector('.start-screen'));
      setScoreBlockVisible(!isStart ? true : false); // hide on start, show otherwise
    } catch(e){
      // fallback: if we can't read gameState, hide when start button exists
      const isStart = !!(document.getElementById('startButton') || document.querySelector('.start-screen'));
      setScoreBlockVisible(!isStart ? true : false);
    }
  }

  document.addEventListener('DOMContentLoaded', onTick);
  window.addEventListener('load', onTick);
  // keep it in sync with any later DOM changes
  setInterval(onTick, 200);
})();
</script>


<script>
// ===== Hamster sprites (v17) =====
(function(){
  const HAM_COUNT = 11; // ham_01..ham_11
  window.hamsterImg = new Array(HAM_COUNT+1).fill(null);
  window.hamsterImgLoaded = new Array(HAM_COUNT+1).fill(false);

  function srcFor(i){
    const id = String(i).padStart(2,'0');
    return withVer(`assets/ham_${id}.png`);
  }

  function preload(){
    for (let i=1;i<=HAM_COUNT;i++){
      const img = new Image();
      img.onload  = ()=> hamsterImgLoaded[i] = true;
      img.onerror = ()=> hamsterImgLoaded[i] = false;
      img.src = srcFor(i);
      hamsterImg[i] = img;
    }
  }
  preload();

  // ç”»åƒãŒã‚ã‚Œã° drawImageã€ç„¡ã‘ã‚Œã°å¾“æ¥ã®ãƒ™ã‚¯ã‚¿ãƒ¼æç”»ã¸ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
window.drawHamster = function(ctx, type, radius){
  // â˜… ã“ã“ãŒãƒã‚¤ãƒ³ãƒˆï¼šã‚²ãƒ¼ãƒ å†… type ã¯ 0 å§‹ã¾ã‚Šãªã®ã§ +1 ã™ã‚‹
  const idx = ((type|0) + 1);
  const t = Math.max(1, Math.min(HAM_COUNT, idx));

  if (hamsterImgLoaded[t]){
    const img = hamsterImg[t];
    const d = radius * 2;
    ctx.drawImage(img, -radius, -radius, d, d); // ä¸­å¿ƒåŸºæº–
  } else if (typeof drawFallbackHamster === 'function'){
    drawFallbackHamster(ctx, type, radius);
  }
};
})();
</script>
<script>
// === eraser sprite ===
const eraserImg = new Image();
let eraserImgLoaded = false;
eraserImg.onload  = ()=> eraserImgLoaded = true;
eraserImg.onerror = ()=> eraserImgLoaded = false;
// ç”»åƒã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ä»˜ä¸ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãŒã‚ã‚‹å ´åˆï¼ˆwithVer/ASSET_VERï¼‰ä½¿ã†
if (typeof withVer === 'function') {
  eraserImg.src = withVer("assets/eraser.png");
} else {
  eraserImg.src = "assets/eraser.png";
}

// æ¶ˆã—ã‚´ãƒ ã‚’åŠå¾„radiusã§ä¸­å¿ƒæç”»ï¼ˆãƒãƒ ã¨åŒã˜åŸºæº–ï¼‰
window.drawEraser = function(ctx, radius){
  if (eraserImgLoaded) {
    const d = radius * 2;
    ctx.drawImage(eraserImg, -radius, -radius, d, d);
  } else {
    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆèª­ã‚ãªã„æ™‚ã¯èµ¤ã„å››è§’ã‚„é‰›ç­†ãªã©ã€å…ƒã®æç”»ã‚’æ®‹ã—ã¦OKï¼‰
    ctx.fillStyle = "#e74c3c";
    ctx.fillRect(-radius, -radius, radius*2, radius*2);
  }
};
</script>
<script>
// --- PWA install controller (replace your current block) ---
if ('serviceWorker' in navigator) {
  // ã¾ã ãªã‚‰SWç™»éŒ²ï¼ˆå¿…é ˆï¼‰
  navigator.serviceWorker.register('./sw.js').catch(console.error);
}

let deferredPrompt = null;

// Installã‚¬ã‚¤ãƒ‰ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹
function showInstallUI(canPrompt) {
  const btn   = document.getElementById('installBtn');   // ã€Œã‚¢ãƒ—ãƒªã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã€ãƒœã‚¿ãƒ³
  const guide = document.getElementById('installGuide'); // æ¡ˆå†…ãƒ†ã‚­ã‚¹ãƒˆã®ã‚³ãƒ³ãƒ†ãƒŠï¼ˆä¸‹ã®ä¾‹ã‚’å‚ç…§ï¼‰
  if (btn)   btn.style.display   = canPrompt ? '' : 'none';
  if (guide) guide.style.display = canPrompt ? 'none' : '';
}

window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  showInstallUI(true);              // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’å‡ºã›ã‚‹ â†’ ãƒœã‚¿ãƒ³ã‚’å‡ºã™
});

window.addEventListener('appinstalled', () => {
  // ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æˆåŠŸã€‚æ¬¡å›ä»¥é™ã¯ãƒœã‚¿ãƒ³ã‚’éš ã™
  deferredPrompt = null;
  localStorage.setItem('pwaInstalled', '1');
  showInstallUI(false);
});

document.addEventListener('DOMContentLoaded', () => {
  const btn = document.getElementById('installBtn');

  // iOS/Safari ã¯ beforeinstallprompt ãŒå‡ºãªã„ â†’ æœ€åˆã‹ã‚‰æ¡ˆå†…UI
  const isiOS = /iphone|ipad|ipod/i.test(navigator.userAgent);
  if (isiOS) showInstallUI(false);

  // ã™ã§ã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿ãªã‚‰ãƒœã‚¿ãƒ³éš ã™
  if (localStorage.getItem('pwaInstalled') === '1') showInstallUI(false);

  if (btn) {
    btn.addEventListener('click', async () => {
      if (deferredPrompt) {
        // â˜… 1å›ã ã‘ä½¿ã†ã€‚çµæœã«é–¢ã‚ã‚‰ãšç ´æ£„
        deferredPrompt.prompt();
        const { outcome } = await deferredPrompt.userChoice;
        deferredPrompt = null;

        if (outcome !== 'accepted') {
          // æ‹’å¦/é–‰ã˜ã‚‰ã‚ŒãŸ â†’ æ¡ˆå†…UIã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
          showInstallUI(false);
        }
      } else {
        // ãã‚‚ãã‚‚ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ãŒå‡ºã›ãªã„ç’°å¢ƒ â†’ æ¡ˆå†…UI
        showInstallUI(false);
      }
    });
  }
});
</script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const url = location.href;

  // â˜… ã“ã“ã‚’å›ºå®šæ–‡ã«ã™ã‚‹
  const shareText = `ğŸ¹ã¯ã‚€ã“ã‚ã‚Šã‚“
ãƒãƒ ã‚¹ã‚¿ãƒ¼ã‚’ã“ã‚ã“ã‚ã—ã¦å¤§ããã™ã‚‹ã‚²ãƒ¼ãƒ ã€ãœã²éŠã‚“ã§ã¿ã¦ã­ï¼
#ã¯ã‚€ã“ã‚ã‚Šã‚“ #ã¯ã‚€ãƒãƒ© #ãƒãƒ ã‚¹ã‚¿ãƒ¼`;

  // Xã‚·ã‚§ã‚¢
  const xBtn = document.getElementById('shareX');
  if (xBtn) {
    xBtn.href = `https://x.com/intent/tweet?url=${encodeURIComponent(url)}&text=${encodeURIComponent(shareText)}`;
  }

  // LINEã‚·ã‚§ã‚¢
  const lineBtn = document.getElementById('shareLine');
  if (lineBtn) {
    lineBtn.href = `https://line.me/R/msg/text/?${encodeURIComponent(shareText + "\\n" + url)}`;
  }

  // URLã‚³ãƒ”ãƒ¼
  const copyBtn = document.getElementById('copyUrlBtn');
  if (copyBtn) {
    copyBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(url);
        copyBtn.textContent = "ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼";
        setTimeout(() => copyBtn.textContent = "URLã‚³ãƒ”ãƒ¼", 2000);
      } catch (e) {
        alert("ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ: " + e);
      }
    });
  }
});

</script>

  
</body>
</html>
<script>(function(){var hud=document.getElementById('playtimeHud'); if(hud) hud.style.display='none';})();</script>
<script>function updatePlaytime() {
  const elapsed = Math.floor((Date.now() - playStartTime) / 1000);
  const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
  const seconds = String(elapsed % 60).padStart(2, '0');
  document.getElementById('playtimeHud').textContent = `ãƒ—ãƒ¬ã‚¤æ™‚é–“:${minutes}:${seconds}`;
}</script>