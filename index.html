<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ğŸ¹ ãƒãƒ ã‚¹ã‚¿ãƒ¼ã®ã‚¹ã‚¤ã‚«ã‚²ãƒ¼ãƒ ï¼ˆç”»åƒç‰ˆï¼‰</title>
  <style>
    body {
      margin: 0;
      padding: 5px;
      background: linear-gradient(135deg, #ffeaa7, #fab1a0);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      box-sizing: border-box;
    }
    .game-container {
      background: #fff;
      border-radius: 8px;
      padding: 8px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.25);
      text-align: center;
      max-width: 99vw;
      max-height: 99vh;
      overflow: hidden;
    }
    .title {
      color: #e17055;
      font-size: 14px;
      font-weight: 800;
      margin: 0 0 4px;
    }
    .score {
      font-size: 12px;
      color: #2d3436;
      margin-bottom: 4px;
    }
    #gameCanvas {
      border: 1px solid #e17055;
      border-radius: 4px;
      background: #74b9ff;
      display: block;
      margin: 0 auto 4px;
    }
    .controls { margin-bottom: 6px; }
    .btn {
      background: #00b894;
      color: #fff;
      border: none;
      padding: 4px 8px;
      border-radius: 10px;
      font-size: 12px;
      cursor: pointer;
      margin: 0 2px;
      transition: transform .15s ease, background .15s ease;
      user-select: none;
    }
    .btn:hover { background: #00a085; transform: translateY(-1px); }

    /* ãƒ¢ãƒ¼ãƒ€ãƒ« */
    .modal { display: none; position: fixed; inset: 0; z-index: 1000; background: rgba(0,0,0,.7); }
    .modal-content {
      background: #fff; margin: 5% auto; padding: 16px; border-radius: 10px; width: 92%; max-width: 560px; max-height: 80vh; overflow: auto;
    }
    .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    .modal-header h2 { color: #e17055; margin: 0; font-size: 18px; }
    .close { color: #999; font-size: 28px; font-weight: 700; cursor: pointer; }
    .close:hover { color: #e17055; }
    .legend-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 10px; }
    .legend-item { display: flex; align-items: center; gap: 8px; padding: 8px; background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 8px; }
    .legend-thumb { width: 28px; height: 28px; border-radius: 50%; object-fit: cover; border: 1px solid #ccc; background: #fff; }
    .legend-name { font-size: 13px; }
  </style>
</head>
<body>
  <div class="game-container">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;gap:8px;">
      <h1 class="title">ğŸ¹ ãƒãƒ ã‚¹ã‚¿ãƒ¼ã®ã‚¹ã‚¤ã‚«ã‚²ãƒ¼ãƒ ï¼ˆç”»åƒç‰ˆï¼‰</h1>
      <div>
        <button class="btn" onclick="showLegend()" title="ãƒãƒ ä¸€è¦§">ğŸ“‹ ä¸€è¦§</button>
        <button class="btn" onclick="resetGame()" style="background:#e74c3c;">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
      </div>
    </div>
    <div class="score">ã‚¹ã‚³ã‚¢: <span id="score">0</span></div>
    <canvas id="gameCanvas" width="350" height="380"></canvas>
    <div class="controls">
      <button class="btn" onclick="moveLeft()">â† å·¦</button>
      <button class="btn" onclick="drop()">â¬‡ ãƒ‰ãƒ­ãƒƒãƒ—</button>
      <button class="btn" onclick="moveRight()">â†’ å³</button>
    </div>
  </div>

  <!-- ãƒ¢ãƒ¼ãƒ€ãƒ«ï¼šãƒãƒ ã‚¹ã‚¿ãƒ¼ä¸€è¦§ -->
  <div id="legendModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>ğŸ¹ ãƒãƒ ã‚¹ã‚¿ãƒ¼ã®ç¨®é¡ï¼ˆç”»åƒã¯ ham1.png ï½ ham11.pngï¼‰</h2>
        <span class="close" onclick="hideLegend()">&times;</span>
      </div>
      <div id="legendGrid" class="legend-grid"></div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');

    // ã‚²ãƒ¼ãƒ ç‰©ç†
    const gravity = 0.4;
    const friction = 0.97;
    const wallBounce = 0.6;
    const groundBounce = 0.2;

    // ãƒãƒ ã®æ®µéšï¼ˆå°â†’å¤§ï¼‰ã€‚ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã¯ ham1.png ï½ ham11.png ã‚’åŒã˜ãƒ•ã‚©ãƒ«ãƒ€ã«ç½®ãã€‚
    // â€»åå‰ã‚„ãƒã‚¤ãƒ³ãƒˆã¯ä»»æ„ã€‚ç”»åƒåã¯è‡ªå‹•ã§å‰²ã‚Šå½“ã¦ã‚‹ã®ã§é…åˆ—ã‚’æ›¸ãæ›ãˆãšã«å·®ã—æ›¿ãˆå¯èƒ½ã€‚
    const foodTypes = [
      { size: 15, points: 1,   name: 'ãƒ‰ãƒ¯ãƒ¼ãƒ•ãƒãƒ ã‚¹ã‚¿ãƒ¼' },
      { size: 20, points: 2,   name: 'ãƒ­ãƒœãƒ­ãƒ•ã‚¹ã‚­ãƒ¼' },
      { size: 25, points: 4,   name: 'ã‚­ãƒ³ã‚¯ãƒ' },
      { size: 30, points: 8,   name: 'ã‚¸ãƒ£ãƒ³ã‚¬ãƒªã‚¢ãƒ³' },
      { size: 35, points: 16,  name: 'ã‚­ãƒ£ãƒ³ãƒ™ãƒ«' },
      { size: 40, points: 32,  name: 'ãƒãƒ£ã‚¤ãƒ‹ãƒ¼ã‚º' },
      { size: 45, points: 64,  name: 'ã‚·ãƒªã‚¢ãƒ³(ã‚¯ãƒªãƒ¼ãƒ )' },
      { size: 50, points: 128, name: 'ã‚·ãƒªã‚¢ãƒ³(ç™½)' },
      { size: 55, points: 256, name: 'ã‚´ãƒ¼ãƒ«ãƒ‡ãƒ³' },
      { size: 60, points: 512, name: 'ãƒ¬ã‚¢ãƒãƒ ã‚¹ã‚¿ãƒ¼' },
      { size: 65, points: 1024,name: 'ä¼èª¬ã®ãƒãƒ ã‚¹ã‚¿ãƒ¼' },
    ];

    // ç”»åƒèª­ã¿è¾¼ã¿ï¼ˆham1.png ï½ ham11.png ã‚’è‡ªå‹•å‰²å½“ï¼‰
    const hamsterImages = {}; // index -> HTMLImageElement
    const hamsterReady   = {}; // index -> booleanï¼ˆèª­ã¿è¾¼ã¿æˆåŠŸï¼‰
    let imagesLoaded = 0;
    const totalImages = foodTypes.length;

    function loadImages() {
      for (let i = 0; i < foodTypes.length; i++) {
        const img = new Image();
        const filename = `ham${i + 1}.png`;
        foodTypes[i].image = filename; // ãƒ‡ãƒãƒƒã‚°/å‡¡ä¾‹è¡¨ç¤ºç”¨ã«ã‚‚ã‚»ãƒƒãƒˆ
        img.onload = () => {
          hamsterReady[i] = true;
          imagesLoaded++;
          // console.log(`Loaded: ${filename}`);
          if (imagesLoaded === totalImages) buildLegend();
        };
        img.onerror = () => {
          hamsterReady[i] = false;
          imagesLoaded++;
          if (imagesLoaded === totalImages) buildLegend();
          console.warn(`ç”»åƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${filename}ï¼ˆã“ã®æ®µã¯ãƒ™ã‚¯ã‚¿ãƒ¼æç”»ã§ä»£æ›¿ï¼‰`);
        };
        img.src = filename;
        hamsterImages[i] = img;
      }
    }

    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
    let gameState = {
      balls: [],
      currentBall: null,
      nextBall: null,
      score: 0,
      dropX: canvas.width / 2,
      gameOver: false,
    };

    class Ball {
      constructor(x, y, type) {
        this.x = x; this.y = y; this.vx = 0; this.vy = 0;
        this.type = type;
        this.radius = foodTypes[type].size;
        this.points = foodTypes[type].points;
        this.name = foodTypes[type].name;
        this.merged = false;
        this.dropTimer = 0;
        this.rotation = 0;
        this.rotationSpeed = 0;
      }
      update() {
        if (this.merged) return;
        this.dropTimer++;
        this.vy += gravity; // é‡åŠ›
        this.vx *= 0.999;   // ç©ºæ°—æŠµæŠ—
        this.vy *= 0.999;
        this.rotationSpeed = this.vx * 0.05;
        this.rotation += this.rotationSpeed;
        this.rotationSpeed *= 0.95;
        this.x += this.vx; this.y += this.vy;
        // å·¦å³ã®å£
        if (this.x - this.radius < 0) {
          this.x = this.radius; this.vx *= -wallBounce; this.vy += (Math.random() - .5);
        }
        if (this.x + this.radius > canvas.width) {
          this.x = canvas.width - this.radius; this.vx *= -wallBounce; this.vy += (Math.random() - .5);
        }
        // åº•
        if (this.y + this.radius > canvas.height) {
          this.y = canvas.height - this.radius; this.vy *= -groundBounce; this.vx *= friction;
          if (Math.abs(this.vx) < 0.1 && Math.abs(this.vy) < 0.1) this.vx += (Math.random() - 0.5) * 0.5;
        }
        this.checkCollisions();
      }
      checkCollisions() {
        for (const other of gameState.balls) {
          if (other === this || other.merged || this.merged) continue;
          const dx = other.x - this.x, dy = other.y - this.y;
          const distance = Math.hypot(dx, dy);
          const minDistance = this.radius + other.radius;
          if (distance < minDistance) {
            if (this.type === other.type && this.type < foodTypes.length - 1) {
              this.merge(other);
            } else {
              const overlap = minDistance - distance;
              const nx = dx / (distance || 1), ny = dy / (distance || 1);
              const sep = overlap * 0.6; // åˆ†é›¢
              this.x -= nx * sep; this.y -= ny * sep;
              other.x += nx * sep; other.y += ny * sep;
              // åç™ºï¼ˆå˜ç´”åŒ–ï¼‰
              const rvx = other.vx - this.vx, rvy = other.vy - this.vy;
              const impulse = (rvx * nx + rvy * ny) * 0.8;
              this.vx += impulse * nx; this.vy += impulse * ny;
              other.vx -= impulse * nx; other.vy -= impulse * ny;
            }
          }
        }
      }
      merge(other) {
        const newType = this.type + 1;
        const newX = (this.x + other.x) / 2;
        const newY = (this.y + other.y) / 2;
        const newBall = new Ball(newX, newY, newType);
        newBall.vy = -0.8; newBall.vx = (Math.random() - 0.5) * 1;
        this.merged = true; other.merged = true;
        gameState.balls.push(newBall);
        gameState.score += newBall.points; updateScore();
      }
      draw() {
        if (this.merged) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        const r = this.radius;
        const img = hamsterImages[this.type];
        if (hamsterReady[this.type]) {
          // ç”»åƒä¸­å¿ƒåˆã‚ã›ã§æç”»ï¼ˆæ­£å††ç›¸å½“ã®å½“ãŸã‚Šåˆ¤å®šãªã®ã§æ­£æ–¹å½¢ã§OKï¼‰
          ctx.drawImage(img, -r, -r, r * 2, r * 2);
          // ãµã¡å–ã‚Šï¼ˆä»»æ„ï¼‰
          ctx.lineWidth = 1;
          ctx.strokeStyle = 'rgba(0,0,0,.15)';
          ctx.beginPath();
          ctx.arc(0, 0, r, 0, Math.PI * 2);
          ctx.stroke();
        } else {
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šãƒ™ã‚¯ã‚¿ãƒ¼æç”»ï¼ˆç”»åƒãŒç„¡ã„æ®µã ã‘ï¼‰
          ctx.fillStyle = '#f1f2f6';
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(0, 0, r * 0.96, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          // ç›®ãƒ»é¼»
          ctx.fillStyle = '#000';
          ctx.beginPath(); ctx.arc(-r * 0.3, -r * 0.2, r * 0.08, 0, Math.PI * 2); ctx.fill();
          ctx.beginPath(); ctx.arc( r * 0.3, -r * 0.2, r * 0.08, 0, Math.PI * 2); ctx.fill();
          ctx.fillStyle = '#ff6b81';
          ctx.beginPath(); ctx.arc(0, r * 0.12, r * 0.05, 0, Math.PI * 2); ctx.fill();
        }
        ctx.restore();
      }
    }

    function initGame() {
      gameState.balls = [];
      gameState.score = 0;
      gameState.gameOver = false;
      gameState.dropX = canvas.width / 2;
      gameState.currentBall = createRandomBall();
      gameState.nextBall = createRandomBall();
      updateScore();
    }

    function createRandomBall() {
      const randomType = Math.floor(Math.random() * Math.min(5, foodTypes.length));
      return { type: randomType };
    }

    function gameLoop() {
      ctx.fillStyle = '#74b9ff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      if (!gameState.gameOver) checkGameOver();
      gameState.balls = gameState.balls.filter(b => !b.merged);
      for (const b of gameState.balls) { b.update(); b.draw(); }
      if (gameState.currentBall && !gameState.gameOver) drawPreviewBall();
      if (gameState.gameOver) drawGameOver();
      requestAnimationFrame(gameLoop);
    }

    function drawPreviewBall() {
      const t = gameState.currentBall.type;
      const r = foodTypes[t].size;
      const y = r + 10;
      ctx.save();
      ctx.globalAlpha = 0.75;
      ctx.translate(gameState.dropX, y);
      const img = hamsterImages[t];
      if (hamsterReady[t]) {
        ctx.drawImage(img, -r, -r, r * 2, r * 2);
      } else {
        ctx.fillStyle = 'rgba(255,255,255,.9)';
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(0, 0, r * 0.96, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
      }
      ctx.restore();
    }

    function checkGameOver() {
      const topLine = 30;
      for (const ball of gameState.balls) {
        if (ball.y - ball.radius < topLine && ball.dropTimer > 120 && Math.abs(ball.vy) < 0.5 && Math.abs(ball.vx) < 0.5) {
          gameState.gameOver = true; break;
        }
      }
    }

    function drawGameOver() {
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,.8)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 24px system-ui, Arial';
      ctx.textAlign = 'center';
      ctx.fillText('ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼!', canvas.width / 2, canvas.height / 2 - 30);
      ctx.font = '16px system-ui, Arial';
      ctx.fillText(`æœ€çµ‚ã‚¹ã‚³ã‚¢: ${gameState.score} ç‚¹`, canvas.width / 2, canvas.height / 2 + 10);
      ctx.font = '12px system-ui, Arial';
      ctx.fillText('ğŸ”„ ãƒªã‚»ãƒƒãƒˆã§å†é–‹', canvas.width / 2, canvas.height / 2 + 36);
      ctx.restore();
    }

    function updateScore() { scoreElement.textContent = gameState.score; }

    function moveLeft() {
      if (gameState.gameOver) return;
      const r = foodTypes[gameState.currentBall.type].size;
      gameState.dropX = Math.max(r, gameState.dropX - 30);
    }
    function moveRight() {
      if (gameState.gameOver) return;
      const r = foodTypes[gameState.currentBall.type].size;
      gameState.dropX = Math.min(canvas.width - r, gameState.dropX + 30);
    }
    function drop() {
      if (gameState.gameOver || !gameState.currentBall) return;
      const t = gameState.currentBall.type;
      const r = foodTypes[t].size;
      const b = new Ball(gameState.dropX, r + 5, t);
      gameState.balls.push(b);
      gameState.currentBall = gameState.nextBall;
      gameState.nextBall = createRandomBall();
    }
    function resetGame() { initGame(); }

    function showLegend() { document.getElementById('legendModal').style.display = 'block'; }
    function hideLegend() { document.getElementById('legendModal').style.display = 'none'; }

    // å‡¡ä¾‹ç”Ÿæˆï¼ˆç”»åƒã¨åç§°ã‚’è¡¨ç¤ºï¼‰
    function buildLegend() {
      const grid = document.getElementById('legendGrid');
      grid.innerHTML = '';
      foodTypes.forEach((t, i) => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        const img = document.createElement('img');
        img.className = 'legend-thumb';
        if (hamsterReady[i]) { img.src = t.image; img.alt = t.name; }
        else {
          // ç”»åƒãŒç„¡ã„æ®µã¯é€æ˜PNGã£ã½ã„è¦‹ãŸç›®ã®ãƒ€ãƒŸãƒ¼
          img.style.background = 'repeating-conic-gradient(#eee 0% 25%, #fff 0% 50%) 50%/10px 10px';
          img.alt = 'ç”»åƒãªã—';
        }
        const span = document.createElement('span');
        span.className = 'legend-name';
        span.textContent = `${i+1}. ${t.name}`;
        item.appendChild(img);
        item.appendChild(span);
        grid.appendChild(item);
      });
    }

    // ã‚­ãƒ¼æ“ä½œ
    document.addEventListener('keydown', (e) => {
      switch (e.key) {
        case 'ArrowLeft': case 'a': case 'A': moveLeft(); break;
        case 'ArrowRight': case 'd': case 'D': moveRight(); break;
        case 'ArrowDown': case ' ': case 's': case 'S': drop(); break;
        case 'r': case 'R': resetGame(); break;
      }
    });

    // èµ·å‹•
    loadImages();
    initGame();
    gameLoop();
  </script>
</body>
</html>