<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>🐹 ハムスターのスイカゲーム（画像版）</title>
  <style>
    body {
      margin: 0;
      padding: 5px;
      background: linear-gradient(135deg, #ffeaa7, #fab1a0);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      box-sizing: border-box;
    }
    .game-container {
      background: #fff;
      border-radius: 8px;
      padding: 8px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.25);
      text-align: center;
      max-width: 99vw;
      max-height: 99vh;
      overflow: hidden;
    }
    .title {
      color: #e17055;
      font-size: 14px;
      font-weight: 800;
      margin: 0 0 4px;
    }
    .score {
      font-size: 12px;
      color: #2d3436;
      margin-bottom: 4px;
    }
    #gameCanvas {
      border: 1px solid #e17055;
      border-radius: 4px;
      background: #74b9ff;
      display: block;
      margin: 0 auto 4px;
    }
    .controls { margin-bottom: 6px; }
    .btn {
      background: #00b894;
      color: #fff;
      border: none;
      padding: 4px 8px;
      border-radius: 10px;
      font-size: 12px;
      cursor: pointer;
      margin: 0 2px;
      transition: transform .15s ease, background .15s ease;
      user-select: none;
    }
    .btn:hover { background: #00a085; transform: translateY(-1px); }

    /* モーダル */
    .modal { display: none; position: fixed; inset: 0; z-index: 1000; background: rgba(0,0,0,.7); }
    .modal-content {
      background: #fff; margin: 5% auto; padding: 16px; border-radius: 10px; width: 92%; max-width: 560px; max-height: 80vh; overflow: auto;
    }
    .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    .modal-header h2 { color: #e17055; margin: 0; font-size: 18px; }
    .close { color: #999; font-size: 28px; font-weight: 700; cursor: pointer; }
    .close:hover { color: #e17055; }
    .legend-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 10px; }
    .legend-item { display: flex; align-items: center; gap: 8px; padding: 8px; background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 8px; }
    .legend-thumb { width: 28px; height: 28px; border-radius: 50%; object-fit: cover; border: 1px solid #ccc; background: #fff; }
    .legend-name { font-size: 13px; }
  </style>
</head>
<body>
  <div class="game-container">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;gap:8px;">
      <h1 class="title">🐹 ハムスターのスイカゲーム（画像版）</h1>
      <div>
        <button class="btn" onclick="showLegend()" title="ハム一覧">📋 一覧</button>
        <button class="btn" onclick="resetGame()" style="background:#e74c3c;">🔄 リセット</button>
      </div>
    </div>
    <div class="score">スコア: <span id="score">0</span></div>
    <canvas id="gameCanvas" width="350" height="380"></canvas>
    <div class="controls">
      <button class="btn" onclick="moveLeft()">← 左</button>
      <button class="btn" onclick="drop()">⬇ ドロップ</button>
      <button class="btn" onclick="moveRight()">→ 右</button>
    </div>
  </div>

  <!-- モーダル：ハムスター一覧 -->
  <div id="legendModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>🐹 ハムスターの種類（画像は ham1.png ～ ham11.png）</h2>
        <span class="close" onclick="hideLegend()">&times;</span>
      </div>
      <div id="legendGrid" class="legend-grid"></div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');

    // ゲーム物理
    const gravity = 0.4;
    const friction = 0.97;
    const wallBounce = 0.6;
    const groundBounce = 0.2;

    // ハムの段階（小→大）。画像ファイルは ham1.png ～ ham11.png を同じフォルダに置く。
    // ※名前やポイントは任意。画像名は自動で割り当てるので配列を書き換えずに差し替え可能。
    const foodTypes = [
      { size: 15, points: 1,   name: 'ドワーフハムスター' },
      { size: 20, points: 2,   name: 'ロボロフスキー' },
      { size: 25, points: 4,   name: 'キンクマ' },
      { size: 30, points: 8,   name: 'ジャンガリアン' },
      { size: 35, points: 16,  name: 'キャンベル' },
      { size: 40, points: 32,  name: 'チャイニーズ' },
      { size: 45, points: 64,  name: 'シリアン(クリーム)' },
      { size: 50, points: 128, name: 'シリアン(白)' },
      { size: 55, points: 256, name: 'ゴールデン' },
      { size: 60, points: 512, name: 'レアハムスター' },
      { size: 65, points: 1024,name: '伝説のハムスター' },
    ];

    // 画像読み込み（ham1.png ～ ham11.png を自動割当）
    const hamsterImages = {}; // index -> HTMLImageElement
    const hamsterReady   = {}; // index -> boolean（読み込み成功）
    let imagesLoaded = 0;
    const totalImages = foodTypes.length;

    function loadImages() {
      for (let i = 0; i < foodTypes.length; i++) {
        const img = new Image();
        const filename = `ham${i + 1}.png`;
        foodTypes[i].image = filename; // デバッグ/凡例表示用にもセット
        img.onload = () => {
          hamsterReady[i] = true;
          imagesLoaded++;
          // console.log(`Loaded: ${filename}`);
          if (imagesLoaded === totalImages) buildLegend();
        };
        img.onerror = () => {
          hamsterReady[i] = false;
          imagesLoaded++;
          if (imagesLoaded === totalImages) buildLegend();
          console.warn(`画像が見つかりません: ${filename}（この段はベクター描画で代替）`);
        };
        img.src = filename;
        hamsterImages[i] = img;
      }
    }

    // ゲーム状態
    let gameState = {
      balls: [],
      currentBall: null,
      nextBall: null,
      score: 0,
      dropX: canvas.width / 2,
      gameOver: false,
    };

    class Ball {
      constructor(x, y, type) {
        this.x = x; this.y = y; this.vx = 0; this.vy = 0;
        this.type = type;
        this.radius = foodTypes[type].size;
        this.points = foodTypes[type].points;
        this.name = foodTypes[type].name;
        this.merged = false;
        this.dropTimer = 0;
        this.rotation = 0;
        this.rotationSpeed = 0;
      }
      update() {
        if (this.merged) return;
        this.dropTimer++;
        this.vy += gravity; // 重力
        this.vx *= 0.999;   // 空気抵抗
        this.vy *= 0.999;
        this.rotationSpeed = this.vx * 0.05;
        this.rotation += this.rotationSpeed;
        this.rotationSpeed *= 0.95;
        this.x += this.vx; this.y += this.vy;
        // 左右の壁
        if (this.x - this.radius < 0) {
          this.x = this.radius; this.vx *= -wallBounce; this.vy += (Math.random() - .5);
        }
        if (this.x + this.radius > canvas.width) {
          this.x = canvas.width - this.radius; this.vx *= -wallBounce; this.vy += (Math.random() - .5);
        }
        // 底
        if (this.y + this.radius > canvas.height) {
          this.y = canvas.height - this.radius; this.vy *= -groundBounce; this.vx *= friction;
          if (Math.abs(this.vx) < 0.1 && Math.abs(this.vy) < 0.1) this.vx += (Math.random() - 0.5) * 0.5;
        }
        this.checkCollisions();
      }
      checkCollisions() {
        for (const other of gameState.balls) {
          if (other === this || other.merged || this.merged) continue;
          const dx = other.x - this.x, dy = other.y - this.y;
          const distance = Math.hypot(dx, dy);
          const minDistance = this.radius + other.radius;
          if (distance < minDistance) {
            if (this.type === other.type && this.type < foodTypes.length - 1) {
              this.merge(other);
            } else {
              const overlap = minDistance - distance;
              const nx = dx / (distance || 1), ny = dy / (distance || 1);
              const sep = overlap * 0.6; // 分離
              this.x -= nx * sep; this.y -= ny * sep;
              other.x += nx * sep; other.y += ny * sep;
              // 反発（単純化）
              const rvx = other.vx - this.vx, rvy = other.vy - this.vy;
              const impulse = (rvx * nx + rvy * ny) * 0.8;
              this.vx += impulse * nx; this.vy += impulse * ny;
              other.vx -= impulse * nx; other.vy -= impulse * ny;
            }
          }
        }
      }
      merge(other) {
        const newType = this.type + 1;
        const newX = (this.x + other.x) / 2;
        const newY = (this.y + other.y) / 2;
        const newBall = new Ball(newX, newY, newType);
        newBall.vy = -0.8; newBall.vx = (Math.random() - 0.5) * 1;
        this.merged = true; other.merged = true;
        gameState.balls.push(newBall);
        gameState.score += newBall.points; updateScore();
      }
      draw() {
        if (this.merged) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        const r = this.radius;
        const img = hamsterImages[this.type];
        if (hamsterReady[this.type]) {
          // 画像中心合わせで描画（正円相当の当たり判定なので正方形でOK）
          ctx.drawImage(img, -r, -r, r * 2, r * 2);
          // ふち取り（任意）
          ctx.lineWidth = 1;
          ctx.strokeStyle = 'rgba(0,0,0,.15)';
          ctx.beginPath();
          ctx.arc(0, 0, r, 0, Math.PI * 2);
          ctx.stroke();
        } else {
          // フォールバック：ベクター描画（画像が無い段だけ）
          ctx.fillStyle = '#f1f2f6';
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(0, 0, r * 0.96, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          // 目・鼻
          ctx.fillStyle = '#000';
          ctx.beginPath(); ctx.arc(-r * 0.3, -r * 0.2, r * 0.08, 0, Math.PI * 2); ctx.fill();
          ctx.beginPath(); ctx.arc( r * 0.3, -r * 0.2, r * 0.08, 0, Math.PI * 2); ctx.fill();
          ctx.fillStyle = '#ff6b81';
          ctx.beginPath(); ctx.arc(0, r * 0.12, r * 0.05, 0, Math.PI * 2); ctx.fill();
        }
        ctx.restore();
      }
    }

    function initGame() {
      gameState.balls = [];
      gameState.score = 0;
      gameState.gameOver = false;
      gameState.dropX = canvas.width / 2;
      gameState.currentBall = createRandomBall();
      gameState.nextBall = createRandomBall();
      updateScore();
    }

    function createRandomBall() {
      const randomType = Math.floor(Math.random() * Math.min(5, foodTypes.length));
      return { type: randomType };
    }

    function gameLoop() {
      ctx.fillStyle = '#74b9ff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      if (!gameState.gameOver) checkGameOver();
      gameState.balls = gameState.balls.filter(b => !b.merged);
      for (const b of gameState.balls) { b.update(); b.draw(); }
      if (gameState.currentBall && !gameState.gameOver) drawPreviewBall();
      if (gameState.gameOver) drawGameOver();
      requestAnimationFrame(gameLoop);
    }

    function drawPreviewBall() {
      const t = gameState.currentBall.type;
      const r = foodTypes[t].size;
      const y = r + 10;
      ctx.save();
      ctx.globalAlpha = 0.75;
      ctx.translate(gameState.dropX, y);
      const img = hamsterImages[t];
      if (hamsterReady[t]) {
        ctx.drawImage(img, -r, -r, r * 2, r * 2);
      } else {
        ctx.fillStyle = 'rgba(255,255,255,.9)';
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(0, 0, r * 0.96, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
      }
      ctx.restore();
    }

    function checkGameOver() {
      const topLine = 30;
      for (const ball of gameState.balls) {
        if (ball.y - ball.radius < topLine && ball.dropTimer > 120 && Math.abs(ball.vy) < 0.5 && Math.abs(ball.vx) < 0.5) {
          gameState.gameOver = true; break;
        }
      }
    }

    function drawGameOver() {
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,.8)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 24px system-ui, Arial';
      ctx.textAlign = 'center';
      ctx.fillText('ゲームオーバー!', canvas.width / 2, canvas.height / 2 - 30);
      ctx.font = '16px system-ui, Arial';
      ctx.fillText(`最終スコア: ${gameState.score} 点`, canvas.width / 2, canvas.height / 2 + 10);
      ctx.font = '12px system-ui, Arial';
      ctx.fillText('🔄 リセットで再開', canvas.width / 2, canvas.height / 2 + 36);
      ctx.restore();
    }

    function updateScore() { scoreElement.textContent = gameState.score; }

    function moveLeft() {
      if (gameState.gameOver) return;
      const r = foodTypes[gameState.currentBall.type].size;
      gameState.dropX = Math.max(r, gameState.dropX - 30);
    }
    function moveRight() {
      if (gameState.gameOver) return;
      const r = foodTypes[gameState.currentBall.type].size;
      gameState.dropX = Math.min(canvas.width - r, gameState.dropX + 30);
    }
    function drop() {
      if (gameState.gameOver || !gameState.currentBall) return;
      const t = gameState.currentBall.type;
      const r = foodTypes[t].size;
      const b = new Ball(gameState.dropX, r + 5, t);
      gameState.balls.push(b);
      gameState.currentBall = gameState.nextBall;
      gameState.nextBall = createRandomBall();
    }
    function resetGame() { initGame(); }

    function showLegend() { document.getElementById('legendModal').style.display = 'block'; }
    function hideLegend() { document.getElementById('legendModal').style.display = 'none'; }

    // 凡例生成（画像と名称を表示）
    function buildLegend() {
      const grid = document.getElementById('legendGrid');
      grid.innerHTML = '';
      foodTypes.forEach((t, i) => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        const img = document.createElement('img');
        img.className = 'legend-thumb';
        if (hamsterReady[i]) { img.src = t.image; img.alt = t.name; }
        else {
          // 画像が無い段は透明PNGっぽい見た目のダミー
          img.style.background = 'repeating-conic-gradient(#eee 0% 25%, #fff 0% 50%) 50%/10px 10px';
          img.alt = '画像なし';
        }
        const span = document.createElement('span');
        span.className = 'legend-name';
        span.textContent = `${i+1}. ${t.name}`;
        item.appendChild(img);
        item.appendChild(span);
        grid.appendChild(item);
      });
    }

    // キー操作
    document.addEventListener('keydown', (e) => {
      switch (e.key) {
        case 'ArrowLeft': case 'a': case 'A': moveLeft(); break;
        case 'ArrowRight': case 'd': case 'D': moveRight(); break;
        case 'ArrowDown': case ' ': case 's': case 'S': drop(); break;
        case 'r': case 'R': resetGame(); break;
      }
    });

    // 起動
    loadImages();
    initGame();
    gameLoop();
  </script>
</body>
</html>